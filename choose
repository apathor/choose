#!/bin/bash
# choose - Line selection abstraction (plus utilities!)
# Source this file to enable completion and expose internal functions.
#
# Supported tools:
#  dmenu    : https://tools.suckless.org/dmenu/
#  fzf      : https://github.com/junegunn/fzf
#  iselect  : http://www.ossp.org/pkg/tool/iselect/
#  pick     : https://github.com/mptre/pick
#  rofi     : https://github.com/davatorium/rofi
#  sentaku  : https://github.com/rcmdnk/sentaku
#  slmenu   : https://bitbucket.org/rafaelgg/slmenu
#  vis-menu : https://github.com/martanne/vis
# by Mike Lalumiere 2019

chuz() {
    # usage
    read -r -d '' use <<EOF
chuz < INPUT > LINE
Select one line from input.
EOF
    # prepend a number to each line of input
    local ind lines
    mapfile -t lines
    for ((ind=0; ind < "${#lines[@]}"; ind++)); do
        printf "% 5d %s\n" "$ind" "${lines[$ind]}" >&2
    done < <(printf "%s\n" "${lines[@]}")
    # prompt interactively to select a line number
    shopt -s nocasematch
    while read -p "#? " -r sel < /dev/tty; do
        if ! [[ "$sel" =~ ^[0-9]+$ ]]; then
            # MAYBE tput reset >&2
            # given a non-number perform a string search
            for ((ind=0; ind < "${#lines[@]}"; ind++)); do
                if [[ "${lines[$ind]}" =~ $sel ]]; then
                    printf "% 5d %s\n" "$ind" "${lines[$ind]}" >&2
                fi
            done < <(printf "%s\n" "${lines[@]}")
        else
            # line number must be within boundaries
            if [ "$sel" -lt "${#lines[@]}" ]; then
                break
            fi
        fi
    done
    shopt -u nocasematch
    # needs a selection
    if [ -z "$sel" ]; then return 2; fi
    # print the selected line
    printf "%s\n" "${lines[$sel]}"
}

choose() {
    # usage
    read -r -d '' use <<EOF
choose [OPTIONS] < LINES - choose a line using an appropriate tool
     --OR--
choose [OPTIONS] [PLUGIN] [ARGS] - run a plugin that uses choose!

OPTIONS
 -h : display this usage text
 -l : list known plugins
 -g : force graphical mode
 -t : force text mode

ENVIRONMENT
 CHOOSE_GUI : preferred interface - 1=graphical 0=terminal
 CHOOSE_BINS_GUI : list of graphical utilities in order of preference
 CHOOSE_BINS_TTY : list of terminal utilities in order of preference

EXAMPLES
 $ printf "%s\n" foo bar qux | choose
 $ cd \$(choose dir)
 $ emacs -nw \$(choose file)
 $ curl -sS https://tools.ietf.org/rfc/index | choose uri
 $ ssh \$(choose host)
 $ choose \$(choose -l | choose)

Currently supported tools:
 dmenu fzf iselect pick rofi sentaku slmenu vis-menu
EOF
    # some selection utils are graphical or terminal-only
    local gfx="${CHOOSE_GUI}"
    # figure available graphical program
    read -r -a gbins <<< "${CHOOSE_BINS_GUI:-dmenu rofi}"
    for it in "${gbins[@]}"; do
        if type "$it" &>/dev/null; then gbin="$it"; break; fi
    done
    # figure available terminal program
    read -r -a tbins <<< "${CHOOSE_BINS_TTY:-fzf pick iselect slmenu vis-menu sentaku}"
    for it in "${tbins[@]}"; do
        if type "$it" &>/dev/null; then tbin="$it"; break; fi
    done
    # accept options
    local opt OPTIND OPTARG
    while getopts ":hlgqt" opt; do
        case "$opt" in
            g) # try to use a graphical program for line selection
                gfx=1
                ;;
            t) # try to use a terminal program for line selection
                gfx=0
                ;;
            l) # list detected plugins
                while read -r f; do
                    if [[ "$f" == choose_* ]]; then
                        printf "%s\n" "${f##choose_}"
                    fi
                done < <(compgen -c) | sort
                return 0
                ;;
            q) # list supported programs
                printf "%s\n" "${gbins[@]}" "${tbins[@]}" | sort
                return 0
                ;;
            h) # write some help text
                printf "%s\n" "$use" >&2
                return 0
                ;;
            \?) # invalid option?
                printf "Bad option: -%s\n %s\n" "$OPTARG" "$use" >&2
                return 2
                ;;
        esac
    done
    shift $((OPTIND - 1))
    # use a graphical program if possible by default
    if [ -z "$gfx" ] && [ -n "$DISPLAY" ]; then gfx=1; fi
    # allow an indefinite article
    if [[ "$1" =~ ^an?$ ]]; then shift; fi
    # plugins - any command in the format 'choose_$WORD'
    if [ -n "$1" ]; then
        local plug="choose_$1"
        if type "$plug" &>/dev/null; then
            shift
            CHOOSE_GUI="$gfx" eval "$plug" "$@"
            return "$?"
        else
            printf "%s function or command not found.\n" "$plug" >&2
            return 3
        fi
    fi
    # if not attached
    if [ "$#" -eq 0 ] && [ -t 0 ]; then
        printf "%s\n" "$use" >&2
        return 0
    fi
    # read stdin
    mapfile -t lines
    # using a util of the appropriate flavor...
    if ((gfx)); then app="$gbin"; else app="$tbin"; fi
    # choose a line
    printf "%s\n" "${lines[@]}" | \
        case "$app" in
            dmenu    ) dmenu -i -l 30 ;;
            fzf      ) fzf ;;
            iselect  ) iselect -a ;;
            pick     ) pick ;;
            rofi     ) rofi -dmenu -p "" ;;
            sentaku  ) sentaku -s $'\n' | head -n1 ;;
            slmenu   ) slmenu -i -l 30 ;;
            vis-menu ) vis-menu -i -l 30 ;;
            *        ) chuz ;;
        esac
    return 0
}

####

# command completion
function _choose() {
    local cur opts
    cur="${COMP_WORDS[COMP_CWORD]}"
    opts=$(printf -- "-%s " g h l q t)
    COMPREPLY=($(compgen -W "$(choose -l) $opts" -- "$cur"))
}
complete -F _choose choose

# choose from available plugins
choose_meta() {
    local it
    it=$(choose "-l" | choose)
    if [ -z "$it" ]; then return 2; fi
    choose "$it"
}

# choose a command on your path to execute
choose_exec() {
    local bin
    bin=$(choose < <(compgen -c))
    if [ -z "$bin" ]; then return 2; fi
    # printf "%s\n" "$bin"
    exec "$bin"
}

# choose a host in your hostfile
choose_host() {
    # choose a host
    local host
    host=$(choose < <(compgen -A hostname | sort -u))
    if [ -z "$host" ]; then return 2; fi
    printf "%s\n" "$host"
}

# choose a system user
choose_user() {
    # select a user from the password database
    local user
    user=$(compgen -u | choose)
    if [ -z "$user" ]; then return 2; fi
    printf "%s\n" "$user"
}

# choose a system group
choose_group() {
    # select a user from the password database
    local group
    group=$(compgen -g | choose)
    if [ -z "$group" ]; then return 2; fi
    printf "%s\n" "$group"
}

# choose a file under the current or given directory
choose_file() {
    # require find
    if ! type find &>/dev/null; then
        printf "%s - Missing find?\n" "${FUNCNAME[0]}" >&2
    fi
    # accept directory argument
    local dir="${1:-.}"
    if ! [ -d "$dir" ]; then
        return 1
    fi
    # find all files under that directory
    local qot it
    declare -a files
    while IFS= read -rd '' that; do
        # shell quote file names to fit on one line
        qot=$(printf "%q\n" "$that")
        files+=("$qot")
    done < <(find "$dir" -maxdepth 5 -type f -print0)
    # choose one of them
    it=$(printf "%s\n"  "${files[@]}" | choose)
    if [[ -z "$it" ]]; then return 2; fi
    eval printf "$it"
}

# choose a directory under the current or given directory
choose_dir() {
    # require find
    if ! type find &>/dev/null; then
        printf "%s - Missing find?\n" "${FUNCNAME[0]}" >&2
    fi
    # accept directory argument
    local dir="${1:-.}"
    if ! [ -d "$dir" ]; then
        return 1
    fi
    # find all directories under that directory
    local qot it
    declare -a dirs
    while IFS= read -rd '' that; do
        # shell quote file names to fit on one line
        qot=$(printf "%q\n" "$that")
        dirs+=("$qot")
    done < <(find "$dir" -maxdepth 5 -type d -print0)
    # choose one of them
    it=$(printf "%s\n" "${dirs[@]}" | choose)
    if [[ -z "$it" ]]; then return 2; fi
    eval printf "$it"
}

# choose a line from your history
choose_history() {
    # chose a history entry
    local it cmd
    it=$(history | choose)
    read -r _ _ _ cmd <<< "$it"
    if [[ -z "$cmd" ]]; then return 2; fi
    printf "%s\n" "$cmd"
}

# choose an apparix jump bookmark
choose_apparix() {
    # require apparix
    if ! type awk apparix sort &>/dev/null; then
        printf "%s - missing required tools.\n" "${FUNCNAME[0]}" >&2
        return 1
    fi
    # choose an apparix jump
    local sel
    sel=$(apparix | awk '/^j/ { print $2, $3 }' | choose)
    if [ -z "$sel" ]; then return 2; fi
    # write the path
    read -r _ path <<< "$sel"
    printf "%s\n" "$path"
}

# choose an MPD track to play
choose_mpc() {
    # require mpc
    if ! type mpc sort &>/dev/null; then
        printf "%s - missing required tools.\n" "${FUNCNAME[0]}" >&2
        return 1
    fi
    # get current mpd playlist indexed
    mapfile -t tracks < <(mpc -f '%position% [%artist% - %album% - %title%] --  %file%' playlist)
    # choose a track
    local track
    track=$(printf "%s\n" "${tracks[@]}" | choose)
    # play that track
    read -r pos rest <<< "$track"
    if [ -z "$pos" ]; then return 2; fi
    mpc play "$pos"
}

# choose a URI out of stdin and open it in the browser
choose_uri() {
    # require urifind
    if ! type urifind sort &>/dev/null; then
        printf "%s - Missing urifind. Run 'cpanm URI::Find'.\n" "${FUNCNAME[0]}" >&2
        return 1
    fi
    # choose a URI from stdin
    local uri
    uri=$(urifind | choose)
    if [ -z "$uri" ]; then return 2; fi
    # open it in the browser
    # printf "%s\n"
    exec "${BROWSER:-sensible-browser}" "$uri"
}

# choose a password out of pass
choose_pass() {
    # require pass
    if ! type pass find sed &>/dev/null; then
        printf "%s - Missing pass or find.\n" "${FUNCNAME[0]}" >&2
        return 1
    fi
    local pdir files that
    # the password directory
    pdir=${PASSWORD_STORE_DIR:-~/.password-store}
    # find gpg files strip the path and extension
    files=$(find "${pdir%/}/" -name '*.gpg' -type f | sed "s#\.gpg\$##; s#$pdir##")
    # choose an entry
    that=$(printf "%s\n" "${files[@]}" | choose)
    that="${that%%$pdir}"
    if [[ -z "$that" ]]; then return 2; fi
    pass show "$that" | head -n1
}

# choose a lastpass password
choose_lastpass() {
    # require pass
    if ! type lpass &>/dev/null; then
        printf "%s - Missing lpass.\n" "${FUNCNAME[0]}" >&2
        return 1
    fi
    # pick a lastpass password
    local that id
    that=$(lpass ls | choose | grep -Eo 'id: [0-9]+')
    if [[ -z "$that" ]]; then
        echo "No entry selected." >&2
        return 1
    fi
    # dump the password
    id="${that##id: }"
    lpass show --password "$id"
}


# choose an xclip selection, in or out
choose_xclip() {
    # require xclip
    if ! type xclip &>/dev/null; then
        printf "%s - Missing xclip?\n" "${FUNCNAME[0]}" >&2
        return 1
    fi
    # generate menu line for each xclip selection
    local mod="" peek="" item="" menu=()
    for mod in primary secondary clipboard; do
        peek=$(xclip -o -selection "$mod" 2>/dev/null | head -n 1)
        item=$(printf "%s %s\n" "$mod" "$peek")
        menu+=("$item")
    done
    # choose an xclip selection from the menu
    local input line sel
    if [ -t 0 ]; then
        # choose an xclip selection and write its contents
        line=$(printf "%s\n" "${menu[@]}" | choose)
        if [[ -z "$line" ]]; then return 2; fi
        read -r sel _ <<< "$line"
        xclip -o -selection "$sel"
    else
        # choose an xclip selection to store input lines
        mapfile -t input
        line=$(printf "%s\n" "${menu[@]}" | choose)
        if [[ -z "$line" ]]; then return 2; fi
        read -r sel _ <<< "$line"
        printf "%s\n" "${input[@]}" | xclip -i -selection "$sel"
    fi
}

# choose an info page to open
choose_info() {
    # require info
    if ! type info &>/dev/null; then
        printf "%s - Missing info?!\n" "${FUNCNAME[0]}" >&2
        return 1
    fi
    # choose an info page
    local sel man
    sel=$(info -k . | choose)
    if [ -z "$sel" ]; then return 2; fi
    # figure out the selected page
    read -r topic _ <<< "$sel"
    # open that info page
    info "$topic"
}

# choose a manual page to open
choose_man() {
    # require man
    if ! type man &>/dev/null; then
        printf "%s - Missing man?!\n" "${FUNCNAME[0]}" >&2
        return 1
    fi
    # choose a manual page
    local sel man
    sel=$(man -k . | choose)
    if [ -z "$sel" ]; then return 2; fi
    # figure out the selected page
    read -r man sec _ <<< "$sel"
    sec="${sec//\(/}"; sec="${sec//\)/}"
    # open that man page
    man "$sec" "$man"
}

# choose a process and signal to kill it with
choose_process() {
    # require ps
    if ! type ps &>/dev/null; then
        printf "%s - Missing ps?!\n" "${FUNCNAME[0]}" >&2
        return 1
    fi
    # choose a process
    ps aux | choose
    # choose a signal
    return 3
}

# choose a dictionary word
choose_word() {
    # require a dictionary file
    local dict="${1:-/usr/share/dict/words}"
    if ! [ -f "$dict" ]; then
        printf "%s - Missing word file %s \n" "${FUNCNAME[0]}" "$dict" >&2
        return 1
    fi
    # choose a word from the dictionary file
    local word
    word=$(choose < "$dict")
    if [[ -z "$word" ]]; then return 2; fi
    printf "%s\n" "$word"
}

# choose an active file used by git
choose_git() {
    # require find
    if ! type git &>/dev/null; then
        printf "%s - Missing git?\n" "${FUNCNAME[0]}" >&2
        return 1
    fi
    # accept git working directory argument
    local dir="${1:-.}"
    if ! [ -d "$dir" ]; then
        return 1
    fi
    # figure root of repository
    local root
    root=$(git -C "$dir" rev-parse --show-toplevel 2>/dev/null)
    if [ -z "$root" ]; then
        return 2
    fi
    # choose a file from the status list
    local line
    line=$(git -C "$dir" status -sbu | grep -v ^# | choose)
    read -r _ file <<< "$line"
    if [[ -z "$file" ]]; then return 2; fi
    printf "%s/%s\n" "$root" "$file"
}

# choose corrections from input
choose_ispell() {
    # require ispell
    if ! type ispell &>/dev/null; then
        printf "%s - Missing git?\n" "${FUNCNAME[0]}" >&2
        return 1
    fi
    # read input lines
    mapfile -t lines
    # parse ispell spellcheck output
    local line="" index=0
    while read -r symbol rest; do
        # corrections are applied to lines in order
        line="${lines[$index]}"
        # each ispell output line is prefixed by a symbol
        case "$symbol" in
            '') # next
                let index++
                continue
                ;;
            '?') # guess
                false ;;
            '&') # miss
                read -r bad _ _ sug   <<< "$rest"
                IFS=', ' read -r -a fixes <<< "$sug"
                fix=$(printf "%s\n" "${fixes[@]}" | choose)
                if [ -n "$fix" ]; then
                    lines["$index"]="${line/$bad/$fix}"
                fi
                ;;
            '#') # no guess
                continue
                ;;
            '*') # okay
                continue
                ;;
            '+') # root
                continue
                ;;
        esac
    done < <(printf "%s\n" "${lines[@]}" | ispell -a)
    printf "%s\n" "${lines[@]}"
}

# choose an ansible manual page to open
choose_ansibledoc() {
    # require ansible-doc
    if ! type ansible-doc &>/dev/null; then
        printf "%s\n Missing ansible-doc.\n" "${FUNCNAME[0]}" >&2
        return 1
    fi
    # pick a page and read it
    read -r page _ < <(ansible-doc -l | choose)
    if [ -z "$page" ]; then return 2; fi
    ansible-doc "$page"
}

# choose a surfraw elvi
choose_surfraw() {
    # require sr
    if ! type surfraw &>/dev/null; then
        printf "%s\n Missing sr.\n" "${FUNCNAME[0]}" >&2
        return 1
    fi
    # pick an elvi and use it to search
    read -r elvi _ < <(surfraw -elvi | choose)
    if [ -z "$elvi" ]; then return 2; fi
    sr "$elvi" "$*"
}

# run it unless sourced
if [[ "${BASH_SOURCE[0]}" == "$0" ]]; then choose "$@"; fi
