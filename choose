#!/bin/bash
# shellcheck disable=SC2016
# choose - Line selection abstraction (plus utilities!)

# Supported tools:
#  dmenu    : https://tools.suckless.org/dmenu
#  fzf      : https://github.com/junegunn/fzf
#  iselect  : http://www.ossp.org/pkg/tool/iselect
#  pick     : https://github.com/mptre/pick
#  pipedial : https://code.reversed.top/user/xaizek/pipedial
#  rofi     : https://github.com/davatorium/rofi
#  sentaku  : https://github.com/rcmdnk/sentaku
#  slmenu   : https://bitbucket.org/rafaelgg/slmenu
#  vis-menu : https://github.com/martanne/vis
#
# HEY Source this file to enable completion and expose internal functions.
# by Mike Lalumiere 2019
###

req() {
    local x=""
    for x in "$@"; do
        if ! hash "$x" &>/dev/null; then
            printf "%s -- %s is required!\n" "${FUNCNAME[1]}" "$x" >&2
            return 1
        fi
    done
}

chuz() {
    # usage
    read -r -d '' use <<EOF
chuz < INPUT > LINE
Select one line from input.
EOF
    # accept options
    local opt OPTIND OPTARG
    while getopts ":h" opt; do
        case "$opt" in
            *) printf "%s\n" "$use"
               return 1
               ;;
        esac
    done
    shift $((OPTIND - 1))
    # prepend a number to each line of input
    local ind lines
    mapfile -t lines
    for ((ind=0; ind < "${#lines[@]}"; ind++)); do
        printf "% 5d %s\n" "$ind" "${lines[$ind]}" >&2
    done < <(printf "%s\n" "${lines[@]}")
    # prompt interactively to select a line number
    shopt -s nocasematch
    while read -p "#? " -r sel < /dev/tty; do
        if ! [[ "$sel" =~ ^[0-9]+$ ]]; then
            # MAYBE tput reset >&2
            # given a non-number perform a string search
            for ((ind=0; ind < "${#lines[@]}"; ind++)); do
                if [[ "${lines[$ind]}" =~ $sel ]]; then
                    printf "% 5d %s\n" "$ind" "${lines[$ind]}" >&2
                fi
            done < <(printf "%s\n" "${lines[@]}")
        else
            # line number must be within boundaries
            if [ "$sel" -lt "${#lines[@]}" ]; then
                break
            fi
        fi
    done
    shopt -u nocasematch
    # needs a selection
    if [ -z "$sel" ]; then return 2; fi
    # print the selected line
    printf "%s\n" "${lines[$sel]}"
}

choose() {
    # usage
    read -r -d '' use <<EOF
choose [OPTIONS] [< LINES] - choose a line using an appropriate tool
     --OR--
choose [OPTIONS] [PLUGIN] [ARGS] - run a plugin that uses choose!

OPTIONS
 -h         : Help!
 -k         : List supported line selection tools.
 -l         : List detected plugins.

 -0         : Read null terminated lines.
 -d DELIM   : Split on given delimeter during field extraction.
 -f FIELD   : Extract the field at given index from selected line.
 -e COMMAND : Run given command replacing '{}' with the selection.
 -i FILE    : Read selections from given file instead of stdin.

Mutually exclusive options -p, -q, -r set the program mode.
 -p         : Select a line and print it. This is the default.
 -q         : Select a line then print the command given by option -e.
 -r         : Select a line then run the command given by option -e.

Mutually exclusive options -g and -t set preferred line selection tool interface.
 -g         : Use a graphical line selection program.
 -t         : Use a text terminal line selection program.

ENVIRONMENT
 CHOOSE_GUI         : preferred interface - 1=graphical 0=terminal
 CHOOSE_BINS_GUI    : list of graphical utilities in order of preference
 CHOOSE_BINS_TTY    : list of terminal utilities in order of preference
 CHOOSE_DMENU_COLOR : Colon separated colors for dmenu (NF:NB:SF:SB)

EXAMPLES
 $ printf "%s\n" foo bar qux | choose
 $ find . -name '*.yml' -print0 | choose -0
 $ choose -e 'sudo -u {} -i' -d: -f0 < /etc/passwd
 $ cd \$(choose find dir)
 $ choose -e 'dig {} MX' host
 $ choose \$(choose -l | choose)
 $ choose xclip -o | choose -e firefox uri
EOF
    # some selection utils are graphical or terminal-only
    local gfx="${CHOOSE_GUI:-1}"
    # use a graphical program
    if [ -z "$DISPLAY" ]; then gfx=0; fi
    # figure available graphical program
    read -r -a gbins <<< "${CHOOSE_BINS_GUI:-dmenu rofi}"
    for it in "${gbins[@]}"; do
        if type "$it" &>/dev/null; then gbin="$it"; break; fi
    done
    # figure available terminal program
    read -r -a tbins <<< "${CHOOSE_BINS_TTY:-fzf pick pipedial sentaku iselect vis-menu}"
    for it in "${tbins[@]}"; do
        if type "$it" &>/dev/null; then tbin="$it"; break; fi
    done
    # accept options
    # TODO optional prompt?
    local fld="" sel=""       # field or range of fields to extract from selected line
    local exe="${CHOOSE_EXE}" # command template to run with selected line
    local run="${CHOOSE_RUN}" # program mode (0:print selection 1:print command 2:run command)
    local inp="/dev/stdin"    # input file from which to select a line
    local nul=0
    local dlm="$IFS"
    local opt OPTIND OPTARG
    while getopts ":hd:e:f:gi:lkpqrt0" opt; do
        case "$opt" in
            d) # delimeter
                dlm="$OPTARG"
                ;;
            e) # run a command using selection as an argument
                exe="${exe:-$OPTARG}"
                run="${run:-2}"
                if ! [[ "$exe" =~ \{\} ]]; then
                    exe="$exe {}"
                fi
                ;;
            f) # select this field or range of fields
                fld="$OPTARG"
                if ! [[ "$fld" =~ ^([[:digit:]]+)(:([[:digit:]]+)?)?$ ]]; then
                    printf "%s\n" "Bad field selection" >&2
                    return 2
                fi
                fld="${BASH_REMATCH[1]}"
                sel="${BASH_REMATCH[3]:-${BASH_REMATCH[2]}}"
                ;;
            g) # try to use a graphical program for line selection
                gfx=1
                ;;
            i) # selection input file
                inp="$OPTARG"
                if ! [ -r "$inp" ]; then
                    printf "%s\n" "Bad input file" >&2
                    return 2
                fi
                ;;
            t) # try to use a terminal program for line selection
                gfx=0
                ;;
            l) # just list available plugins
                while read -r f; do
                    if [[ "$f" == choose_* ]]; then
                        printf "%s\n" "${f##choose_}"
                    fi
                done < <(compgen -c) | sort
                return 0
                ;;
            k) # just list supported programs
                printf "%s\n" "${gbins[@]}" "${tbins[@]}" | sort
                return 0
                ;;
            p) # print selected line instead of running anything
                run=0
                ;;
            q) # print command that would be run
                run=1
                ;;
            r) # run given command
                run=2
                ;;
            0) # handle null separated input
                nul=1
                ;;
            h) # write some help text
                printf "%s\n" "$use" >&2
                return 0
                ;;
            \?) # invalid option?
                printf "Bad option: -%s\n%s\n" "$OPTARG" "$use" >&2
                return 2
                ;;
        esac
    done
    shift $((OPTIND - 1))
    # allow an indefinite article
    if [[ "$1" =~ ^an?$ ]]; then shift; fi
    # plugins - any command in the format 'choose_$WORD'
    if [ -n "$*" ]; then
        local plug=""
        local args=("$@")
        for ((word=${#args[@]}; word>0; word--)); do
            plug="${args[*]:0:$word}"
            plug="choose_${plug// /_}"
            if type "$plug" >&/dev/null; then break; fi
            plug=""
        done
        if [ -z "$plug" ]; then
            printf "No plugin matching '%s'.\n" "$*" >&2
            return 2
        fi
        shift "$word"
        CHOOSE_RUN="$run" CHOOSE_EXE="$exe" CHOOSE_GUI="$gfx" "$plug" "$@"
        return $?
    fi
    # read selection file
    declare -a lines
    if ((nul)); then
        mapfile -d '' -t lines < "$inp"
    else
        mapfile -t lines < "$inp"
    fi
    # require at least one non-empty line
    if ! (("${#lines[@]}")); then
        return 3
    fi
    # buffer stdin if reading selection input from another file
    declare -a stdin
    if [[ "$inp" != "/dev/stdin" ]] && ! [ -t 0 ]; then
        mapfile -t stdin
        # require some input bytes unless attached to /dev/null
        if [ -z "${stdin[*]}" ] &&
               type readlink &>/dev/null &&
               [ "$(readlink -f /dev/stdin)" != "/dev/null" ]; then
            return 3
        fi
    fi
    # pick an appropriate line selection program
    if ((gfx)); then app="$gbin"; else app="$tbin"; fi
    # choose a line using a known program
    local out
    out=$(case "$app" in
              dmenu    )
                  IFS=':' read -r nf nb sf sb <<< "${CHOOSE_DMENU_COLOR:-white:black:black:white}"
                  dmenu -i -l 30 -nf "$nf"  -nb "$nb" -sf "$sf"  -sb "$sb"
                  ;;
              fzf      ) fzf ;;
              iselect  ) iselect -a ;;
              pick     ) pick ;;
              rofi     ) rofi -i -dmenu -p "" ;;
              pipedial ) pipedial ;;
              sentaku  ) sentaku -s $'\n' | head -n1 ;;
              slmenu   ) slmenu -i -l 30 ;;
              vis-menu ) vis-menu -i -l 30 ;;
              *        ) chuz ;;
          esac < <(if ((nul)); then printf "%q\n" "${lines[@]}"
                   else printf "%s\n" "${lines[@]}"; fi)
       )
    # rectify shell quoted line
    if ((nul)); then
        out=$(eval printf "%s" "$out")
    fi
    # maybe extract some fields from the line
    if [ -n "$fld" ]; then
        IFS="$dlm" read -r -a toks <<< "$out"
        if [ -z "$sel" ]; then
            # N - one specific field
            out="${toks[${fld}]}"
        elif [ "$sel" == ":" ]; then
            # N: - a slice of fields
            out="${toks[*]:${fld}}"
        else
            # N:X - a range of fields
            out="${toks[*]:${fld}:${sel}}"
        fi
    fi
    # terminate if the line is empty
    if [ -z "$out" ]; then
        return 3
    fi
    # maybe generate command
    if [ -n "$exe" ]; then
        # insert argument into command string
        declare -a cmd
        while read -r line; do
            read -r -a toks <<< "$line"
            for tok in "${toks[@]}"; do
                # replace {} if present else append
                if [ "$tok" == "{}" ]; then
                    cmd+=("$(printf "%q" "$out")")
                else
                    cmd+=("$(printf "%q" "$tok")")
                fi
            done
        done <<< "$exe"
    fi
    # do something with the selection depending on mode
    case "${run:-0}" in
        0) # print selection
            printf "%s\n" "$out"
            ;;
        1) # print command
            printf "%s\n" "${cmd[*]}"
            ;;
        2) # run command
            if [ -n "${stdin[*]}" ]; then
                # input for filter commands
                CHOOSE_RUN="" CHOOSE_EXE="" CHOOSE_GUI="$gfx" eval "${cmd[@]}" < <(printf "%s\n" "${stdin[@]}")
            else
                # no input for commands that need an attached terminal
                CHOOSE_RUN="" CHOOSE_EXE="" CHOOSE_GUI="$gfx" eval "${cmd[@]}"
            fi
            return $?
            ;;
    esac
}

####

# choose command completion
function _choose() {
    # get current and previous word
    local pre=""
    if ((COMP_CWORD)); then pre="${COMP_WORDS[COMP_CWORD - 1]}"; fi
    local cur="${COMP_WORDS[COMP_CWORD]}"
    # maybe the previous word is an option that expects an argument
    case "$pre" in
        -d) COMPREPLY=(); return ;;
        -e) COMPREPLY=($(compgen -c -- "$cur")); return ;;
        -f) COMPREPLY=($(compgen -W "0 1 2 3 4 5 6 7 8 9" -- "$cur")); return ;;
        -i) COMPREPLY=($(compgen -f -- "$cur")); return ;;
    esac
    # choose has some options
    declare -A opts
    for opt in -{e,f,g,h,i,l,k,p,t,0}; do opts["$opt"]=0; done
    # choose has some extensions
    # MAYBE complete the first words of extensions
    declare -a exts
    exts=($(choose -l))
    # scan all previous words
    local base=""
    local last word
    for ((i=1; i < COMP_CWORD; i++)); do
        word="${COMP_WORDS[$i]}"
        last="${COMP_WORDS[$i-1]}"
        # have options ended?
        if [[ "$last" =~ ^-[[:alnum:]]^ ]]; then
            # record options already seen
            unset opts["$word"]
        elif [[ "$word" =~ ^[[:alnum:]]+ ]]; then
            # check if options have ended
            if [[ "$last" =~ ^-[defi]$ ]]; then continue; fi
            opts=()
            # concat command prefix
            base="${base}_${word}"
            base="${base##_}"
       fi
    done
    # maybe complete the next part of a multi-word command
    if [ -n "$base" ]; then
        declare -a next
        local pat="^${base}_([[:alnum:]]+)"
        for ext in "${exts[@]}"; do
            if [[ "$ext" =~ $pat ]]; then
                next+=("${BASH_REMATCH[1]}")
            fi
        done
        if (("${#next[@]}")); then
            COMPREPLY=($(compgen -W "${next[*]}" -- "$cur"))
        fi
        return
    fi
    # complete next command token or all arguments and options
    COMPREPLY=($(compgen -W "${!opts[*]} ${exts[*]}" -- "$cur"))
}
complete -F _choose choose

# choose a choose plugin
choose_meta() {
    CHOOSE_DMENU_COLOR="${CHOOSE_DMENU_COLOR:-yellow:black:black:yellow}"
    choose -e "choose" -f 0: -i <(choose -l)
}

# choose a value from arguments
choose_value() {
    choose -i <(printf "%s\n" "$@")
}

# choose a line by number from input
choose_lineno() {
    choose -d : -f 0 -i <(grep -n .)
}

# choose a command on your path
choose_command() {
    CHOOSE_DMENU_COLOR="${CHOOSE_DMENU_COLOR:-black:dark green:white:black}"
    choose -e "exec" -i <(compgen -c)
}

# choose a host in your hostfile
choose_host() {
    choose -i <(compgen -A hostname | sort -u)
}

# choose a system user
choose_user() {
    req getent || return 255
    choose -f 0 -d : -i <(getent user)
}

# choose a system group
choose_group() {
    req getent || return 255
    choose -f 0 -d : -i <(getent group)
}

choose_protocol() {
    req getent || return 255
    choose -f 1 -i <(getent protocols)
}

choose_port() {
    req getent || return 255
    choose -f 1 -i <(getent services | sed 's/\// /')
}

# choose some bash stuff
choose_bash_help() {
    mapfile -t m < <(help -s '*')
    choose -e 'help {}' -d : -f 0 -i <(printf "%s\n" "${m[@]:2}")
}

choose_bash_completion() {
    choose -i <(complete -p)
}

choose_bash_var() {
    choose -i <(compgen -v)
}

choose_bash_job() {
    choose -f 1 -i <(jobs -l)
}

choose_bash_bind_function() {
    choose -i <(bind -l)
}

choose_bash_bind_command() {
    choose -d : -f 1: -i <(bind -X)
}
choose_bash_bind_key() {
    choose -d : -f 0 -i <({ bind -p; bind -X; bind -s; } | grep -v '^#')
}

choose_bash_bind_var() {
    choose -i <(bind -v)
}

# choose a line found with grep
choose_grep() {
    req grep || return 255
    choose -d : -f 0:1 -i <(grep -rn "$@" .)
}

# choose a file under the current or given directory
choose_find_file() {
    req find || return 255
    choose -0 -i <(find "${1:-.}" -iwholename "${2:-*}" -type f -print0)
}

# choose a directory under the current or given directory
choose_find_dir() {
    req find || return 255
    choose -0 -i <(find "${1:-.}" -iwholename "${2:-*}" -type d -print0)
}

# choose a line from your history
choose_history() {
    req sort || return 255
    choose -f 3: -e "eval {}" -i <(HISTTIMEFORMAT="%F %T " history | sort -r -n)
}

# choose an apparix jump bookmark
choose_apparix() {
    req awk apparix || return 255
    choose -f 1 -e "cd" -i <(apparix | awk '/^j/ { print $2, $3 }')
}

# choose an mpd track by index from playlist
choose_mpd_track() {
    CHOOSE_DMENU_COLOR="${CHOOSE_DMENU_COLOR:-white:blue:blue:white}"
    req mpc || return 255
    choose -f 0 -e "mpc play {}" \
           -i <(mpc -f '%position% [%artist% - %album% - %title%] --  %file%' playlist)
}

# choose an mpd output
choose_mpd_output() {
    req mpc || return 255
    choose -f 1 -e "mpc enable {}" -i <(mpc outputs)
}

# choose an mpd tag of various types
declare t="" f=""
for t in artist album genre composer; do
    read -r -d '' f <<EOF
choose_mpd_$t() {
    req mpc || return 255
    choose -e 'mpc search $t' -i <(mpc list $t)
}
EOF
    eval "$f"
done
unset t f

# choose a URI filter from input
choose_uri() {
    CHOOSE_DMENU_COLOR="${CHOOSE_DMENU_COLOR:-white:black:black:green}"
    req urifind || return 255
    choose -e 'sensible-browser' < <(urifind -su)
}

# choose a password out of pass
choose_pass() {
    CHOOSE_DMENU_COLOR="${CHOOSE_DMENU_COLOR:-black:purple:black:red}"
    req pass find sed || return 255
    local pdir="${PASSWORD_STORE_DIR:-$HOME/.password-store}"
    choose -e 'pass show' \
           -i <(find "$pdir" -type f -name '*.gpg' | sed "s#\.gpg##; s#$pdir##")
}

# choose a lastpass password
choose_lastpass() {
    CHOOSE_DMENU_COLOR="${CHOOSE_DMENU_COLOR:-black:purple:red:black}"
    req lpass || return 255
    local menu=()
    local pat='^(.*[^/]) \[id: ([[:digit:]]+)\]$'
    while read -r item; do
        if [[ "$item" =~ $pat ]]; then
            menu+=("${BASH_REMATCH[2]} ${BASH_REMATCH[1]}")
        fi
    done < <(lpass ls)
    choose -f 0 -e "lpass show --password" < <(printf "%s\n" "${menu[@]}")
}

# choose an xclip selection
xclip_brief() {
    local mod buf lns
    for mod in clipboard primary secondary; do
        buf=$(xclip -o -selection "$mod" 2>/dev/null)
        mapfile lns <<< "$buf"
        printf "%s %s %s\n" "$mod" "${#buf}" "${#lns[@]}"
    done
}

choose_xclip_in() {
    CHOOSE_DMENU_COLOR="${CHOOSE_DMENU_COLOR:-black:dark gray:black:red}"
    req xclip || return 255
    choose -f 0 -e 'xclip -selection {} -i' -i <(xclip_brief)
}

choose_xclip_out() {
    CHOOSE_DMENU_COLOR="${CHOOSE_DMENU_COLOR:-black:dark gray:black:green}"
    req xclip || return 255
    choose -f 0 -e 'xclip -selection {} -o' -i <(xclip_brief)
}

# choose an info page to open
choose_info() {
    CHOOSE_DMENU_COLOR="${CHOOSE_DMENU_COLOR:-white:blue:black:green}"
    req info || return 255
    choose -f 0 -e 'info' -i <(info -k .)
}

# choose a manual page to open
choose_man() {
    CHOOSE_DMENU_COLOR="${CHOOSE_DMENU_COLOR:-black:white:yellow:black}"
    req man sed || return 255
    choose -f 0 -e 'man' -i <(man -k . | sed 's/ (/./;s/)//')
}

# choose a process by PID
choose_process() {
    CHOOSE_DMENU_COLOR="${CHOOSE_DMENU_COLOR:-white:blue:black:orange}"
    req ps || return 255
    # build a table of processes
    mapfile table < <(ps ux)
    read -r -a cols <<< "${table[0]}"
    for ((ind=1; ind <= "${#cols[@]}"; ind++)) ; do
        if [[ "${cols[$ind]}" =~ ^(pid|PID)$ ]]; then break; fi
    done
    # pick a process
    choose -f "$ind" <<< "${table[@]:1}"
}

# choose a signal
choose_signal() {
    CHOOSE_DMENU_COLOR="${CHOOSE_DMENU_COLOR:-white:blue:black:red}"
    # build a table of signals
    local name line
    declare -a signals
    for x in {1..64}; do
        name=$(kill -l "$x")
        if [ -z "$name" ]; then continue; fi
        line=$(printf "%02d %s\n" "$x" "$name")
        signals+=("$line")
    done
    # choose a signal
    choose -f 0 < <(printf "%s\n" "${signals[@]}")
}

# choose a process to kill
choose_kill() {
    CHOOSE_DMENU_COLOR="${CHOOSE_DMENU_COLOR:-black:red:green:black}"
    local pid
    if ! pid=$(choose process); then return 2; fi
    choose -e "kill -s {} $pid" signal
}

# choose a word from input
choose_word() {
    req grep sort || return 255
    choose < <(grep -Eo '([[:alpha:][:digit:]])+' | sort -u)
}

# choose some git related stuff
choose_git_file() {
    req git grep || return 255
    choose -f 1 -i <(git status -sbu | grep -v ^#)
}

choose_git_branch() {
    req git || return 255
    choose -f 0 -i <(git branch)
}

choose_git_tag() {
    req git || return 255
    choose -f 0 -i <(git tag)
}

choose_git_commit() {
    req git || return 255
    choose -f 0 -e 'git show' < <(git log --pretty=format:'%h %cI %s (%ce)' --abbrev-commit)
}

# choose some systemd related stuff
choose_systemd_service() {
    req systemctl || return 255
    choose -f 0 -e 'systemctl status' -i <(systemctl list-units -l --type=service --plain --no-legend)
}

choose_systemd_timer() {
    req systemctl || return 255
    choose -f 0 -e 'systemctl status' -i <(systemctl list-units -l --type=timer --plain --no-legend)
}

# choose some tmux related stuff
choose_tmux_command() {
    req tmux || return 255
    choose -f 0 -i <(tmux list-commands)
}

choose_tmux_session() {
    req tmux || return 255
    choose -d : -f 0 -e 'tmux attach-session -t {}' -i <(tmux list-sessions)
}

choose_tmux_pane() {
    req tmux || return 255
    choose -d : -f 0 -e 'tmux select-pane -t {}' -i <(tmux list-panes)
}

choose_tmux_window() {
    req tmux || return 255
    choose -d : -f 0 -e 'tmux select-window -t {}' -i <(tmux list-windows)
}

# choose some screen related stuff
choose_screen_session() {
    req screen || return 255
    choose -f 0 -e 'screen -rd {}' -i <(screen -ls | grep pts)
}

# choose apt related stuff
choose_apt_package() {
    req apt-cache || return 255
    local qry="${*:-.}"
    choose -f 0 -e 'apt-cache show' -i <(apt-cache search "$qry")
}

# choose pulseaudio related stuff
choose_pulseaudio_sink() {
    req pactl || return 255
    choose -f 0 -e 'pactl set-sink-mute {} toggle' < <(pactl list short sinks)
}

choose_pulseaudio_source() {
    req pactl || return 255
    choose -f 0 -e 'pactl set-source-mute {} toggle' < <(pactl list short sources)
}

# choose ip address
choose_ip_route4() {
    req ip || return 255
    choose -f 0 -i <(ip -4 route)
}

choose_ip_route6() {
    req ip || return 255
    choose -f 0 -i <(ip -6 route)
}

choose_ip_addr4() {
    req ip || return 255
    choose -f 2 -i <(ip -br -4 addr)
}

choose_ip_addr6() {
    req ip || return 255
    choose -f 2 -i <(ip -br -6 addr)
}


# choose ispell corrections to replace in input text
choose_ispell() {
    req ispell || return 255
    # read input lines
    mapfile -t lines
    # parse ispell spellcheck output
    local line="" index=0 fix=""
    while read -r symbol rest; do
        # corrections are applied to lines in order
        line="${lines[$index]}"
        # each ispell output line is prefixed by a symbol
        case "$symbol" in
            '') # next
                let index++
                continue
                ;;
            '?') # guess
                : ;;
            '&') # miss
                read -r bad _ _ sug   <<< "$rest"
                IFS=', ' read -r -a fixes <<< "$sug"
                fix=$(printf "%s\n" "${fixes[@]}" | choose)
                if [ -n "$fix" ]; then
                    lines["$index"]="${line/$bad/$fix}"
                fi
                ;;
            '#') # no guess
                continue
                ;;
            '*') # okay
                continue
                ;;
            '+') # root
                continue
                ;;
        esac
    done < <(printf "%s\n" "${lines[@]}" | ispell -a)
    printf "%s\n" "${lines[@]}"
}

# choose a perldoc manual page to open
choose_perldoc() {
    req perldoc || return 255
    choose -f 0 -e "perldoc" < <(perldoc-search .)
}

# choose a pydoc manual page to open
choose_pydoc() {
    req pydoc || return 255
    choose -f 0 -e "pydoc" < <(pydoc -k .)
}

# choose an ansible manual page to open
choose_ansibledoc() {
    req ansible-doc || return 255
    choose -f 0 -e "ansible-doc" < <(ansible-doc -l)
}

# choose a surfraw elvi
choose_surfraw() {
    req surfraw || return 255
    choose -f 0 -e "surfraw {} \"$1\"" < <(surfraw -elvi | sed 1d)
}

# choose some gcloud related stuff
choose_gcloud_role() {
    req gcloud jq || return 255
    choose -f 0 -e 'gcloud iam roles describe' < \
           <(gcloud --format=json iam roles list | jq -r '.[] | [.name, .description] | @tsv')
}

choose_gcloud_instance() {
    req gcloud jq || return 255
    choose -f 0 -e 'gcloud compute instances describe' < \
           <(gcloud --format=json compute instances list | \
                 jq -r '.[] | [.id, .name, (.zone | split("/")[-1]), .networkInterfaces[0].networkIP // "-", .accessConfigs[0].natIP // "-", .status] | @tsv')
}

choose_gcloud_project() {
    req gcloud jq || return 255
    choose -f 0 -e 'gcloud projects describe' < \
           <(gcloud --format=json projects list | jq -r '.[] | [.projectId, .name] | @tsv')
}

choose_gcloud_serviceaccount() {
    req gcloud jq || return 255
    choose -f 0 -e 'gcloud iam service-accounts describe' < \
           <(gcloud --format=json iam service-accounts list | jq -r '.[] | [.email, .displayName, .email] | @tsv')
}

choose_mime_type() {
    req grep /etc/mime.types || return 255
    choose -f 0 -i <(grep -v -e '^#' -e '^$' /etc/mime.types)
}

choose_locate() {
    req locate || return 255
    choose -0 -i <(locate -i -0 "${@:-$PWD}")
}

choose_xrandr_monitor() {
    req xrandr sed || return 255
    choose -f 0 -i <(xrandr --listmonitors | sed '1d')
}

choose_xrandr_provider() {
    req xrandr sed || return 255
    choose -f 0 -i <(xrandr --listproviders | sed '1d')
}

choose_json() {
    req jq || return 255
    if ! [ -f "$1" ]; then return 1; fi
    choose -e "jq -r {} $1" -i <(jq -r '"." + (path(..) | map("[\(tojson)]") | join(""))' "$1")
}

choose_xml_element() {
    req xmlstarlet || return 255
    if ! [ -f "$1" ]; then return 1; fi
    choose -e "xmlstarlet sel -B -t -c {} $1" < <(xmlstarlet el -v "$1")
}

choose_xml_value() {
    req xmlstarlet || return 255
    if ! [ -f "$1" ]; then return 1; fi
    choose -e "xmlstarlet sel -B -t -v {} $1" < <(xmlstarlet el -v "$1")
}

choose_avconv_format() {
    req avconv sed || return 255
    choose -f 1 -i <(avconv -loglevel 0  -formats | sed 1,4d)
}

choose_avconv_encoder() {
    req avconv sed || return 255
    choose -f 1 -i <(avconv -loglevel 0 -encoders | sed 1,10d)
}

choose_avconv_decoder() {
    req avconv sed || return 255
    choose -f 1 -i <(avconv -loglevel 0 -decoders | sed 1,10d)
}

choose_sysctl() {
    req sysctl || return 255
    choose -f 0 -i <(sysctl -a 2>/dev/null)
}

choose_dict_strategy() {
    req dict sed || return 255
    choose -f 0 -i <(dict -S | sed 1d)
}

choose_dict_word() {
    req dict sed || return 255
    choose -f 0 -i <(dict -m -f -s re '.*')
}

# run it unless sourced
if [[ "${BASH_SOURCE[0]}" == "$0" ]]; then choose "$@"; fi
