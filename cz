#!/usr/bin/env bash
# shellcheck disable=SC2031
#
# cz - Line selection abstraction (plus utilities!)
# (C) 2020 by Mike Lalumiere
#
# TODO Optional caching of input text
# TODO Establish plugin exit status convention
# TODO Completion hook function?
# TODO Option to specify prompt (see 'dmenu -p foo')
# TODO AWS/s3 plugins
# TODO I8n?

if (("${BASH_VERSINFO[0]}" < 4)); then
    printf "%s\n" "$0 requires bash 4!" >&2
    return 255
fi

acc() {
    # usage
    read -r -d '' use <<EOF
acc [FILE] < INPUT > PATH
Given a file path check that the path is readable and print the file name.
Given input on stdin redirect to a temp file and print the file name.
EOF
    # no options just help
    local opt OPTIND OPTARG
    while getopts ":h" opt; do
        case "$opt" in
            *) printf "%s\n" "$use" >&2
               return 1
               ;;
        esac
    done
    shift $((OPTIND - 1))
    # accept arguments
    local file="${1:-/dev/stdin}"
    local out="$file"
    if ! [ -r "$file" ]; then
        return 1
    fi
    # capture pipe in a temporary file
    if [ "$file" == "/dev/stdin" ]; then
        out=$(printf "/tmp/acc.%s.%(%s)T\n" "$RANDOM" "-1")
        printf "%s\n" "$(< "$file")" > "$out"
    fi
    # write out the file name
    printf "%s\n" "$out"
};

chuz() {
    # usage
    read -r -d '' use <<EOF
chuz < INPUT > LINE
Select one line from input.
EOF
    # no options just help
    local opt OPTIND OPTARG
    while getopts ":h" opt; do
        case "$opt" in
            *) printf "%s\n" "$use" >&2
               return 1
               ;;
        esac
    done
    shift $((OPTIND - 1))
    # prepend a number to each line of input
    local ind lines
    mapfile -t lines
    for ((ind=0; ind < "${#lines[@]}"; ind++)); do
        printf "% 5d %s\n" "$ind" "${lines[$ind]}" >&2
    done < <(printf "%s\n" "${lines[@]}")
    # prompt interactively to select a line number
    shopt -s nocasematch
    while read -p "#? " -r sel < /dev/tty; do
        if ! [[ "$sel" =~ ^[0-9]+$ ]]; then
            # given a non-number perform a string search
            for ((ind=0; ind < "${#lines[@]}"; ind++)); do
                if [[ "${lines[$ind]}" =~ $sel ]]; then
                    printf "% 5d %s\n" "$ind" "${lines[$ind]}" >&2
                fi
            done < <(printf "%s\n" "${lines[@]}")
        else
            # line number must be within boundaries
            if [ "$sel" -lt "${#lines[@]}" ]; then
                break
            fi
        fi
    done
    shopt -u nocasematch
    # needs a selection
    if [ -z "$sel" ]; then return 2; fi
    # print the selected line
    printf "%s\n" "${lines[$sel]}"
}

hep() {
    read -r -d '' use <<EOF
hep TOGGLE < INPUT > OUTPUT
Print input text if TOGGLE is non-empty, otherwise fail.
This is a utility function to aid in optionally printing a block of usage text.
Example:
 $ { hep "\$HELP_TOGGLE" && return; } <<<EOF ...
EOF
    # no option but help
    local opt OPTIND OPTARG
    while getopts ":h" opt; do
        case "$opt" in
            *)
                printf "%s\n" "$use" >&2
                return 1
                ;;
        esac
    done
    shift $((OPTIND - 1))
    # let input through if given an argument
    if [ -n "$1" ]; then
        printf "%s\n" "$(< /dev/stdin)" >&2
    else
        return 1
    fi
}

req() {
    read -r -d '' use <<EOF
req COMMAND/FILE [...]
Require given files and commands.
Succeed iff each given argument is a known command or readable file.
This is a utility function to aid in defining program requirements.
Example:
 $ req awk /etc/passwd || return 5
EOF
    # no options just help
    local opt OPTIND OPTARG
    while getopts ":h" opt; do
        case "$opt" in
            *)
                printf "%s\n" "$use" >&2
                return 1
                ;;
        esac
    done
    shift $((OPTIND - 1))
    # consider each argument as a file or command
    local mis=0
    local arg=""
    for arg in "$@"; do
        if [ -r "$arg" ]; then continue; fi
        if type "$arg" &>/dev/null; then continue; fi
        ((mis++))
        printf "%s -- %s is required!\n" "${FUNCNAME[1]}" "$arg" >&2
    done
    # fail if any argument is missing
    ! ((mis))
}

nth() {
    read -r -d '' use <<EOF
nth [OPTIONS] TEMPLATE [ARG ...]
Generate a string from TEMPLATE replacing variables of the following format:
 {X}     : argument X
 {X:}    : arguments X through end of arguments
 {X:Y}   : arguments X through X + Y
 {X,Y,Z} : arguments X, Y, and Z

OPTIONS
 -p : print output normally
 -q : print output quoted for use in the shell

EXAMPLE
 $ nth '{1} {0} {0}' foo bar
 $ nth '{2:2}' 1 2 3 4 5
 $ nth '{7,4,11,11,14}' {a..z}
EOF
    # accept options
    local fmt='%s'
    local opt OPTIND OPTARG
    while getopts ":hpq" opt; do
        case "$opt" in
            p) # plain format
                fmt='%s'
                ;;
            q) # quoted format
                fmt='%q'
                ;;
            *) # invalid?
                printf "%s\n" "$use" >&2
                return 1
                ;;
        esac
    done
    shift $((OPTIND - 1))
    # require template argument
    local tmpl="$1"
    shift
    if [ -z "$tmpl" ]; then
        printf "%s\n" "$use" >&2
        return 1
    fi
    # remaining arguments are tokens
    local toks=("$@")
    # collecting output string segments
    local segs=()
    # parse field selection...
    local str="" fld="" idx=0 suf=0 mode="text"
    tmpl+=" "
    while (( idx < "${#tmpl}" )); do
        # consider each character
        char="${tmpl:$idx:1}"
        next="${tmpl:$((idx + 1)):1}"
        # switch on parser mode
        if [[ "$mode" == "text" ]]; then
            # literal text mode
            case "$char" in
                '{')
                    # start parsing a variable
                    if [[ "$next" == '{' ]]; then
                        str+='{'
                        let idx++
                    else
                        mode="var"
                    fi
                    ;;
                '}')
                    # maybe close an escaped var
                    str+="$char"
                    if [[ "$next" == '}' ]]; then
                        let idx++
                    fi
                    ;;
                ' ')
                    # append a suffix or a new field
                    if [ -n "$str" ]; then
                        if ((suf)); then
                            segs[-1]+="$str"
                        else
                            segs+=("$str")
                        fi
                    fi
                    # reset for next string
                    str=""
                    suf=0
                    ;;
                *)
                    # accumulate characters
                    str+="$char"
                    ;;
            esac
        elif [[ "$mode" == "var" ]]; then
            # variable mode
            case "$char" in
                '{') # escaped literal curly brace
                    str+="$char"
                    mode="text"
                    ;;
                [,\}]) # field separator
                    # match and validate the field
                    if ! [[ "$fld" =~ ^(-?[[:digit:]]+)(:([[:digit:]]+)?)?$ ]]; then
                        printf "Invalid field string '%s'\n" "$fld" >&2
                        return 3
                    fi
                    # get matched groups - field and range
                    local sel len
                    sel="${BASH_REMATCH[1]}"
                    len="${BASH_REMATCH[3]:-${BASH_REMATCH[2]}}"
                    if [ -z "$len" ]; then
                        # N - one specific field
                        segs+=("$(printf "%s${fmt}" "${str}" "${toks[$sel]}")")
                        str=""
                    elif [ "$len" == ":" ]; then
                        # N: - a slice of fields
                        for tok in "${toks[@]:$((sel))}"; do
                            segs+=("$(printf "%s${fmt}" "$str" "$tok")")
                            str=""
                        done
                    else
                        # N:X - a range of fields
                        if [[ "$len" -lt 1 ]]; then
                            printf "Invalid range '%s'\n" "$len" >&2
                            return 3
                        fi
                        for tok in "${toks[@]:$((sel)):$((len))}"; do
                            segs+=("$(printf "%s${fmt}" "$str" "$tok")")
                            str=""
                        done
                    fi
                    # maybe done with this variable
                    if [[ "$char" == '}' ]]; then
                        mode="text"
                        suf=1
                    fi
                    # reset field
                    fld=""
                    str=""
                    ;;
                [[:digit:]:-]) # valid field chars
                    fld+="$char"
                    ;;
                *) # invalid
                    printf "Could not parse character '%s' at index %d.\n\n%s\n" "$char" "$idx" "$use" >&2
                    return 3
                    ;;
            esac
        fi
        # next character
        let idx++
    done
    # check if parsing ended cleanly
    if [[ "$mode" == "var" ]]; then
        printf "Unclosed variable delimeter?\n%s\n" "$use"  >&2
        return 3
    fi
    # generate output string maybe with shell quotes
    local out
    out=$(printf "%s " "${segs[@]}")
    # strip trailing whitespace
    out="${out%${out##*[![:space:]]}}"
    # write it
    printf "%s\n" "$out"
}

rleval() {
    read -r -d '' use <<EOF
rleval COMMAND...
Evaluate given command and insert output into the bash readline buffer.
The command is templated with 'nth' using current line tokens. See 'nth -h'.
This function is intended to be used with the bash builtin 'bind -x'.

Examples:
 Insert the first token from the current readline buffer.
 $ bind -x '"\C-x0":rleval "echo {0}"'

 Insert fortunes on demand!
 $ bind -x '"\C-xf":rleval fortune"'

EOF
    # command is required
    if ! (($#)); then
        printf "%s\n" "$use" >&2
        return 1
    fi
    local args="$*"
    # record current readline point
    local before="${READLINE_LINE:0:$READLINE_POINT}"
    local after="${READLINE_LINE:$READLINE_POINT}"
    # tokenize current readline line
    local toks=()
    read -r -a toks <<< "$READLINE_LINE"
    # template command
    local cmd=""
    if ! cmd="$(nth -p "$args" "${toks[@]}")"; then
        return 2
    fi
    # eval command
    local str=""
    if ! str=$(eval -- "$cmd"); then
        return 3
    fi
    # update the readline buffer
    READLINE_LINE="${before}${str}${after}"
    ((READLINE_POINT += ${#str}))
}

rlword() {
        read -r -d '' use <<EOF
rlword COMMAND...
Evaluate given command and replace the word at cursor in the readline buffer.
Command is templated with 'nth' using the word at point and current line tokens
 in that order. The word at cursor point is '{0}'. See 'nth -h'.
This function is intended to be used with the bash builtin 'bind -x'.

Examples:
 Replace the current word with a generated password.
 $ bind -x '"\C-xp":rlword "pwgen 20 1"'

 Replace the current word with itself reversed.
 $ bind -x '"\C-xt":rlword "rev <<< {0}"'

 Replace the current word with one already in the readline buffer.
 $ bind -x '"\C-xy":rlword "cz argv {1:}"'

 Have some fun with base64!
 $ bind -x '"\C-xb":rlword "base64 <<< {0}"'
 $ bind -x '"\C-xB":rlword "base64 -d <<< {0}"'
EOF
    # command is required
    if ! (($#)); then
        printf "%s\n" "$use" >&2
        return 1
    fi
    # tokenize current readline line
    local toks=()
    read -r -a toks <<< "$READLINE_LINE"
    # determine word at point
    local line="$READLINE_LINE" pt="$READLINE_POINT"
    local beg=0 end=0 ins=0 word=""
    if [[ "${line:$pt:1}" == ' ' ]]; then
        # insert a word if point is on a space
        beg="$pt"
        end="$pt"
        ins=1
    else
        # replace word at point if on a non-space character
        local x=0
        # find beginning of the word
        beg=0
        for ((x="$pt"; x>=0; x--)); do
            if [[ "${line:$x:1}" == ' ' ]]; then
                beg=$((x + 1))
                break
            fi
        done
        # find end of the word
        end="${#line}"
        for ((x="$pt"; x<="${#line}"; x++)); do
            if [[ "${line:$x:1}" == ' ' ]]; then
                end="$x"
                break
            fi
        done
        # grab the word
        word="${line:$beg:$(( end - beg ))}"
    fi
    # template command
    local cmd=""
    if ! cmd=$(nth -q "$*" "$word" "${toks[@]}"); then
        return 2
    fi
    # eval command
    local str=""
    if ! str=$(eval -- "$cmd"); then
        return 3
    fi
    # wrap inserted words in spaces
    if ((ins)); then
        str=" ${str} "
    fi
    # update the readline buffer
    READLINE_LINE="${line:0:$beg}${str}${line:$end}"
    READLINE_POINT=$((beg + ${#str}))
}

# bind -x '"\C-x;":echo "$READLINE_POINT"'

###

cz() {
    # version
    local ver="0.1"
    # usage
    local hows="" use=""
    read -r -d '' use <<EOF
cz [OPTIONS] < LINES
Select a line from input with an appropriate tool.

cz [OPTIONS] [PLUGIN] [ARGS ...]
Run a plugin to select something application specific.

OPTIONS
 These options print some information and exit:
  -h : help     : Print this help text or help text for plugin.
  -k : tools    : List supported line selection tools.
  -l : plugins  : List detected plugins.
  -v : version  : Print version string.

 These options set program mode. Select a line then...
  -p : print    : Print the line. This is the default mode.
  -q : quote    : Print extracted FIELDS from the line.
  -r : run      : Run the string formatted by TEMPLATE using fields from the line.
  -s : simulate : Print the string formatted by TEMPLATE using fields from the line.

 General options:
  -d DELIMITER  : Set delimiter to split selected line.
  -e TEMPLATE   : Set command template. This option implies mode '-r'.
  -f FIELDS     : Set field template. This option implies mode '-q'.
  -i IN-FILE    : Set file from which to read selections instead of stdin.
  -x            : Use a graphical line selection tool.
  -y            : Use a text terminal line selection tool.
  -z TOOL       : Use the given line selection tool.
  -0            : Read null terminated lines from input.

TEMPLATES
 Substrings of TEMPLATE in the following formats are replaced with
  one or more fields from a selected line split by DELIM.
     {X}     - field X
     {X:}    - fields X through end of fields
     {X:Y}   - fields X through X + Y
     {X,Y,Z} - fields X, Y, and Z
 FIELDS consists of one of the above without the enclosing '{}'.

ENVIRONMENT
 CZ_GUI         : preferred interface - 1=graphical 0=terminal
 CZ_BINS_GUI    : list of graphical utilities in order of preference
 CZ_BINS_TTY    : list of terminal utilities in order of preference
 CZ_DMENU_COLOR : Colon separated colors for dmenu (NF:NB:SF:SB)

TOOLS
 Supported line selection tools are dmenu, fzf, iselect, pick,
  pipedial, rofi, sentaku, slmenu, and vis-menu.
EOF
    # examples
    read -r -d '' hows <<EOF
 $ printf "%s\n" foo bar qux | cz
 $ find . -name '*.yml' -print0 | cz -0
 $ cz -f 0,5 -d : < /etc/passwd
 $ cd \$(cz find dir)
 $ cz \$(cz -l | cz)
 $ cz -e 'dig {1} MX' compgen hostname
 $ cz xclip out | cz -e 'firefox {0}' uri
 $ cz -e 'cz jq {0}' locate *.json
 $ cz -e 'cz -q find file {1}' apparix
 $ cz -e 'rev <<< "{0:}"' -i <(printf "%s\n" '$HOST' '; false' '\$(fortune)')
EOF
    printf "%s\n" "${hows[$(( RANDOM % ${#hows[@]} ))]}" >/dev/null
    # here are the supporterd line selection tools
    local gbins=() tbins=()
    read -r -a gbins <<< "${CZ_BINS_GUI:-dmenu rofi}"
    read -r -a tbins <<< "${CZ_BINS_TTY:-fzf pick pipedial sentaku iselect vis-menu}"
    # determine type of interface for line selection tool
    local app="" gfx=""
    IFS=: read -r gfx app _ <<< "${CZ_GUI:-1}"
    if [ -z "$DISPLAY" ]; then gfx=0; fi
    # accept options
    local tpl="${CZ_TEMPLATE}" # string template
    local fld="${CZ_FIELDS}"   # string field selection
    local mode="${CZ_MODE}"    # integer program mode
    local inp="/dev/stdin"     # string file from which to select a line
    local run=""               # null program mode implied by another option
    local nul=0                # boolean reading null separated lines
    local dlm="$IFS"           # string delimeter to split selected line
    local help="${CZ_HELP}"    # string indicator for help requested
    local opt OPTIND OPTARG
    while getopts ":d:e:f:hi:lkpqrsvxyz:0" opt; do
        case "$opt" in
            d) # delimeter
                dlm="$OPTARG"
                ;;
            e) # template to format command
                tpl="${tpl:-$OPTARG}"
                run=2
                ;;
            f) # fields to be extracted
                fld="${fld:-${OPTARG}}"
                if ! [[ "$fld" =~ ^([0-9]+(:[0-9]+?)?,?)*$ ]]; then
                   printf "Invalid field template '%s'\n" "$fld" >&2
                   return 2
                fi
                run=1
                ;;
            h) # user needs assistance
                help="YES PLEASE"
                ;;
            i) # input file from which to read selections
                inp="$OPTARG"
                if ! [ -r "$inp" ]; then
                    printf "%s\n" "Input file is unreadable!" >&2
                    return 2
                fi
                ;;
            l) # list available plugins
                while read -r f; do
                    if [[ "$f" == cz_* ]]; then
                        printf "%s\n" "${f##cz_}"
                    fi
                done < <(compgen -c) | sort
                return 0
                ;;
            k) # list supported tools
                read -r -d '' exes <<EOF
dmenu     https://tools.suckless.org/dmenu
fzf       https://github.com/junegunn/fzf
iselect   http://www.ossp.org/pkg/tool/iselect
pick      https://github.com/mptre/pick
pipedial  https://code.reversed.top/user/xaizek/pipedial
rofi      https://github.com/davatorium/rofi
sentaku   https://github.com/rcmdnk/sentaku
slmenu    https://bitbucket.org/rafaelgg/slmenu
vis-menu  https://github.com/martanne/vis
EOF
                printf "%s\n" "$exes"
                return 0
                ;;
            p) # print selected line instead of running anything
                mode=0
                ;;
            q) # print fields from extrated line provided by '-f' option
                mode=1
                ;;
            r) # run template provided by by '-e' option
                mode=2
                ;;
            s) # print template provided by by '-e' option
                mode=3
                ;;
            0) # handle null separated input
                nul=1
                ;;
            v) # write version
                printf "cz %s\n" "$ver"
                return 0
                ;;
            x) # try to use a graphical tool for line selection
                gfx=1
                ;;
            y) # try to use a terminal tool for line selection
                gfx=0
                ;;
            z) # force some specific tool
                app="$OPTARG"
                # shellcheck disable=SC2076
                if ! [[ "${gbins[*]} ${tbins[*]}" =~ "${app}" ]]; then
                    printf "Unknown tool %s\n" "$app" >&2
                    return 2
                fi
                ;;
            \?) # invalid option?
                printf "Bad option: -%s\n%s\n" "$OPTARG" "$use" >&2
                return 2
                ;;
        esac
    done
    shift $((OPTIND - 1))
    # pick an appropriate line selection tool
    if [ -z "$app" ]; then
        if ((gfx)); then
            for app in "${gbins[@]}"; do
                if type "$app" &>/dev/null; then break; fi
            done
        else
            for app in "${tbins[@]}"; do
                if type "$app" &>/dev/null; then break; fi
            done
        fi
    fi
    # program mode might have been implied
    mode="${mode:-$run}"
    # plugins - any command in the format 'cz_$WORD'
    if [ -n "$*" ]; then
        # determine if a known plugin is given
        local plug=""
        local args=("$@")
        local word=0
        for ((word=${#args[@]}; word>0; word--)); do
            plug="${args[*]:0:$word}"
            plug="cz_${plug// /_}"
            if type "$plug" >&/dev/null; then break; fi
            plug=""
        done
        # bail out for invalid plugins
        if [ -z "$plug" ]; then
            printf "No plugin matching '%s'.\n" "$*" >&2
            return 2
        fi
        shift "$word"
        # run the plugin with override environment variables
        CZ_GUI="${gfx}:${app}"  CZ_HELP="$help" CZ_MODE="$mode" \
              CZ_FIELDS="$fld" CZ_TEMPLATE="$tpl" \
              "$plug" "$@"
        return $?
    fi
    # maybe help was requested
    if [ -n "$help" ]; then
        printf "%s\n" "$use" >&2
        return
    fi
    # read selection file
    declare -a lines
    if ((nul)); then
        mapfile -d '' -t lines < "$inp"
    else
        mapfile -t lines < "$inp"
    fi
    # require at least one non-empty line
    if ! (("${#lines[@]}")); then
        return 3
    fi
    # buffer stdin if reading selection input from another file
    declare -a stdin
    if [[ "$inp" != "/dev/stdin" ]] && ! [ -t 0 ]; then
        mapfile -t stdin
        # require some input bytes unless attached to /dev/null
        if [ -z "${stdin[*]}" ] &&
               type readlink &>/dev/null &&
               [ "$(readlink -f /dev/stdin)" != "/dev/null" ]; then
            return 4
        fi
    fi
    # choose a line using a known program
    local out
    out=$(case "$app" in
              dmenu    )
                  local color="${CZ_DMENU_COLOR:-white:black:black:white}"
                  IFS=':' read -r nf nb sf sb <<< "$color"
                  dmenu -i -l 30 -nf "$nf"  -nb "$nb" -sf "$sf"  -sb "$sb"
                  ;;
              fzf      ) fzf ;;
              iselect  ) iselect -a ;;
              pick     ) pick ;;
              rofi     ) rofi -i -dmenu -p "" ;;
              pipedial ) pipedial ;;
              sentaku  ) sentaku -s $'\n' | head -n1 ;;
              slmenu   ) slmenu -i -l 30 ;;
              vis-menu ) vis-menu -i -l 30 ;;
              chuz     ) chuz ;;
              * )
              ;;
          esac < <(if ((nul)); then
                       printf "%q\n" "${lines[@]}"
                   else
                       printf "%s\n" "${lines[@]}"
                   fi)
       )
    # rectify shell quoted line
    if ((nul)); then
        out=$(eval printf "%s" "$out")
    fi
    # terminate if the line is empty
    if [ -z "$out" ]; then
        return 3
    fi
    # tokenize selected line for use in templates
    local cmd=""
    local toks=()
    IFS="$dlm" read -r -a toks <<< "$out"
    # set harmless defaults for template arguments
    tpl="${tpl:-echo {0:\}}"
    fld="${fld:-0:}"
    # do something with the selection depending on mode
    case "${mode:-0}" in
        0) # print selection
            printf "%s\n" "$out"
            ;;
        1) # print some fields extracted from the line
            if ! out="$(nth -p "{${fld}}" "${toks[@]}")"; then
                printf "Failed to parse template.\n%s\n" "$fld" >&2
                return 4
            fi
            printf "%s\n" "$out"
            ;;
        2) # template the command string and run it
            if ! cmd="$(nth -q "${tpl}" "${toks[@]}")"; then
                printf "Failed to parse template.\n%s\n" "$tpl" >&2
                return 4
            fi
            # eval the template string maybe passing buffered input
            if [ -n "${stdin[*]}" ]; then
                CZ_MODE="" CZ_FIELDS="" CZ_TEMPLATE="" CZ_GUI="${gfx}:${app}" \
                       eval "$cmd" < <(printf "%s\n" "${stdin[@]}")
            else
                CZ_MODE="" CZ_FIELDS="" CZ_TEMPLATE="" CZ_GUI="${gfx}:${app}" \
                       eval "$cmd"
            fi
            return $?
            ;;
        3) # template the command string and print it
            if ! cmd="$(nth -p "${tpl}" "${toks[@]}")"; then
                printf "Failed to parse template.\n%s\n" "$tpl" >&2
                return 4
            fi
            printf "%s\n" "$cmd"
            ;;
    esac
}

# cz command completion
function _cz() {
    # get lists of supported tools and plugins
    local tools=() plugs=()
    mapfile -t tools < <(cz -k)
    mapfile -t plugs < <(cz -l)
    # cz has some options
    declare -A opts
    for opt in -{d,e,f,h,i,l,k,p,q,r,s,v,x,y,z,0}; do opts["$opt"]=0; done
    # scan all previous words
    local base="" last="" word="" i=0
    for ((i=1; i < "$COMP_CWORD"; i++)); do
        # step through words
        word="${COMP_WORDS[$i]}"
        last="${COMP_WORDS[$i-1]}"
        # have options ended?
        if [[ "$word" =~ ^-[[:alnum:]]$ ]]; then
            # record options already seen
            unset opts["$word"]
        elif [[ "$word" =~ ^[[:alnum:]]+ ]]; then
            # maybe this is an argument to an option
            if [[ "$last" =~ ^-[defiz]$ ]]; then continue; fi
            opts=()
            # concat plugin prefix
            base="${base}_${word}"
            base="${base##_}"
       fi
    done
    # current and previous words are given
    local prev="${3}"
    local curr="${2}"
    # maybe the previous word is an option that expects an argument
    if [[ "$prev" =~ ^-[defiz]$ ]]; then
        case "$prev" in
            -d) COMPREPLY=(); ;;
            -e) COMPREPLY=($(compgen -c -- "$curr")) ;;
            -f) COMPREPLY=($(compgen -W "0 1 2 3 4 5 6 7 8 9" -- "$curr")) ;;
            -i) COMPREPLY=($(compgen -f -- "$curr")) ;;
            -z) COMPREPLY=($(compgen -W "${tools[*]%% *}"  -- "$curr")) ;;
        esac
        return
    fi
    # first complete initial command token and options
    if [ -z "$base" ]; then
        COMPREPLY=($(compgen -W "${!opts[*]} ${plugs[*]%%_*}" -- "$curr"))
        return
    fi
    # determine next command token
    local next=() pat="^${base}_([[:alnum:]]+)"
    for plug in "${plugs[@]}"; do
        if [[ "$plug" =~ $pat ]]; then
            next+=("${BASH_REMATCH[1]%%_*}")
        fi
    done
    # maybe complete next command token
    if (("${#next[@]}")); then
        COMPREPLY=($(compgen -W "${next[*]}" -- "$curr"))
        return
    fi
    # TODO maybe complete something specific for a plugin
    case "$base" in
        *) return ;;
    esac
}
complete -F _cz cz

####

cz_argv() {
    { hep "$CZ_HELP" && return; } <<EOF
$ cz argv [ARGS]
Select from given arguments.
EOF
    cz -i <(printf "%s\n" "$@")
}

cz_anagram() {
    { hep "$CZ_HELP" && return; } <<EOF
cz anagram TEXT [WORDS]
Select from anagrams of TEXT.
Optionally limit to a maximum number of WORDS.
EOF
    req an || return 5
    cz -i <(an -l "${2:-3}" "$1")
}

cz_ansible_group() {
    { hep "$CZ_HELP" && return; } <<EOF
cz ansible group
Select a group from an ansible inventory then draw a graph of its members.
See ANSIBLE_INVENTORY and ANSIBLE_CONFIG environment variables.
EOF
    req ansible-inventory jq || return 5
    cz -f 0 -e 'ansible-inventory --graph {0}' \
       -i <(ansible-inventory --list | \
                jq -r '. | keys[] | select(. | test("^_") | not)')
}

cz_ansible_host() {
    { hep "$CZ_HELP" && return; } <<EOF
cz ansible host
Select a host from an ansible inventory then print its variables as JSON.
See ANSIBLE_INVENTORY and ANSIBLE_CONFIG environment variables.
EOF
    req ansible-inventory jq || return 5
    cz -f 0 -e 'ansible-inventory --host {0}' \
       -i <(ansible-inventory --list | \
                jq -r '[.[] | select(.hosts!=null) | .hosts[]] | flatten | unique[]')
}

cz_ansible_doc() {
    { hep "$CZ_HELP" && return; } <<EOF
cz ansible doc
Select from ansible documentation topics.
EOF
    req ansible-doc || return 5
    cz -f 0 -e "ansible-doc {0}" < <(ansible-doc -l)
}

cz_apparix() {
    { hep "$CZ_HELP" && return; } <<EOF
cz apparix
Select from apparix bookmarks.
EOF
    req apparix awk || return 5
    cz -f 1 -e "cd {1}" -i <(apparix | awk '/^j/ { print $2, $3 }')
}

cz_apparix_file() {
    { hep "$CZ_HELP" && return; } <<EOF
cz apparix file
Select from files within selected apparix bookmark directory.
EOF
    local dir
    dir="$(CZ_MODE="" CZ_FIELDS="" cz -q apparix)"
    if [ -z "$dir" ]; then return 2; fi
    cz find file "$dir"
}

cz_apt_package() {
    { hep "$CZ_HELP" && return; } <<EOF
cz apt package [QUERY]
Select from apt package listings matching QUERY.
EOF
    req apt-cache || return 5
    local qry="${*:-.}"
    cz -f 0 -e 'apt-cache show {0}' -i <(apt-cache search "$qry")
}

cz_avconv_format() {
    { hep "$CZ_HELP" && return; } <<EOF
cz avconv format
Select from data formats supported by avconv.
EOF
    req avconv sed || return 5
    cz -f 1 -i <(avconv -loglevel 0 -formats | sed 1,4d)
}

cz_avconv_encoder() {
    { hep "$CZ_HELP" && return; } <<EOF
cz avconv encoder
Select from encoders supported by avconv.
EOF
    req avconv sed || return 5
    cz -f 1 -i <(avconv -loglevel 0 -encoders | sed 1,10d)
}

cz_avconv_decoder() {
    { hep "$CZ_HELP" && return; } <<EOF
cz avconv decoder
Select from decoders supported by avconv.
EOF
    req avconv sed || return 5
    cz -f 1 -i <(avconv -loglevel 0 -decoders | sed 1,10d)
}

cz_bash_bind_function() {
    { hep "$CZ_HELP" && return; } <<EOF
cz bash bind function
Select from bash internal readline functions.
EOF
    cz -i <(bind -l)
}

cz_bash_bind_key() {
    { hep "$CZ_HELP" && return; } <<EOF
cz bash bind key
Select from bash key bindings.
EOF
    cz -d : -f 0 -i <({ bind -p; bind -X; bind -s; } | grep -v '^#')
}

cz_bash_completion() {
    { hep "$CZ_HELP" && return; } <<EOF
cz bash completion
Select from bash completion function configuration.
EOF
    cz -i <(complete -p)
}

cz_bash_help() {
    { hep "$CZ_HELP" && return; } <<EOF
cz bash help
Select from bash help topics.
EOF
    mapfile -t m < <(help -s '*')
    cz -f 0 -e 'help {0}' -d : -i <(printf "%s\n" "${m[@]:2}")
}

cz_bash_job() {
    { hep "$CZ_HELP" && return; } <<EOF
cz bash job
Select from bash background jobs.
EOF
    cz -f 1 -e 'fg {1}' -i <(jobs -l)
}

cz_bash_history() {
    { hep "$CZ_HELP" && return; } <<EOF
cz bash history
Select from bash command history.
EOF
    req sort || return 5
    cz -f 3: -e "{3:}" -i <(HISTTIMEFORMAT="%F %T " history | sort -r -n)
}

cz_bool() {
    { hep "$CZ_HELP" && return; } <<EOF
cz bool
Select a true or false value.
EOF
    cz -e 'let {0}'  -i <(printf "%s\n" "1 yes true" "0 no false")
}

declare n=""
while read -r n _; do
    eval "cz_compgen_$n() { \
    { hep \"\$CZ_HELP\" && return; } <<EOF
cz compgen $n [PREFIX]
Select from bash builtin $n completion.
EOF
cz -i <(compgen -A $n -- \"\$1\" | sort);\
}"
done <<EOF
alias
arrayvar
binding
builtin
command
directory
disabled
enabled
export
file
function
group
helptopic
hostname
job
keyword
running
service
setopt
shopt
signal
stopped
user
variable
EOF
unset n

cz_command() {
    { hep "$CZ_HELP" && return; } <<EOF
cz command
Select a command and run it.
EOF
    CZ_DMENU_COLOR="${CZ_DMENU_COLOR:-black:dark green:white:black}"
    cz -f 0 -e '{0}' compgen command
}

cz_dict_strategy() {
    { hep "$CZ_HELP" && return; } <<EOF
cz dict strategy
Select a dict server search strategy.
EOF
    req dict sed || return 5
    cz -f 0 -i <(dict -S | sed 1d)
}

cz_dict_word() {
    { hep "$CZ_HELP" && return; } <<EOF
cz dict word [QUERY]
Select a word from a dict server and print its definition.
EOF
    req dict || return 5
    local qry="${1:-.*}"
    cz -f 3: -e 'dict {3:}' -i <(dict -m -f -s re "$qry")
}

cz_dnf_package() {
    { hep "$CZ_HELP" && return; } <<EOF
cz dnf package
Select a dnf package by name then print info about it.
EOF
    req dnf sed || return 5
    cz -f 0 -e 'dnf info {0}' -i <(dnf list 2>/dev/null | sed 1,2d)
}

cz_dns_rtype() {
    { hep "$CZ_HELP" && return; } <<EOF
cz dnf package
Select a DNS rdata type.
EOF
    local rtypes=(A AAAA AFSDB APL CAA CDNSKEY CDS CERT CNAME CSYNC DHCID DLV DNAME
                  DNSKEY DS HINFO HIO IPSECKEY KEY KX LOC MX NAPTR NS NSEC NSEC3
                  NSEC3PARAM OPENPGPKEY PTR RRSIG RP SIG SMIMEA SOA SRV SSHFP TA
                  TKEY TLSA TSIG TXT URI
                  IXFR AXFR OPT)
    cz -i <(printf "%s\n" "${rtypes[@]}")
}

cz_docker_container() {
    { hep "$CZ_HELP" && return; } <<EOF
cz docker container
Select a docker container.
EOF
    req docker sed || return 5
    cz -f 0 -e 'docker inspect {0}' \
       -i <(docker container ls -a | sed 1d)
}

cz_docker_image() {
    { hep "$CZ_HELP" && return; } <<EOF
cz docker image
Select a docker image.
EOF
    req docker sed || return 5
    cz -f 2 -e 'docker inspect {2}' \
       -i <(docker images -a | sed 1d)
}

cz_docker_ps() {
    { hep "$CZ_HELP" && return; } <<EOF
cz docker ps
Select a running docker container process.
EOF
    req docker sed || return 5
    cz -f 0 -e 'docker inspect {0}' \
       -i <(docker ps | sed 1d)
}

cz_fc_font() {
    { hep "$CZ_HELP" && return; } <<EOF
cz fc font
Select a font file known to fontconfig.
EOF
    req fc-list || return 5
    cz -f 0 -d : -i <(fc-list)
}

cz_figlet_font() {
    { hep "$CZ_HELP" && return; } <<EOF
cz figlet font
Select a font file usable by figlet.
EOF
    req figlet || return 5
    local fdir="${FIGLET_FONTDIR:-/usr/share/figlet}"
    cz -f 0 -e "figlet -t -d $fdir -f {0}" \
           -i <(for f in "$fdir"/*f; do
                    printf "%s %s\n" "${f##*/}" "${f}"
                done)
}

cz_find_file() {
    { hep "$CZ_HELP" && return; } <<EOF
cz find file [DIRECTORY] [PATTERN]
Select a file under DIRECTORY (or current working directory)
 with full path matching PATTERN.
EOF
    req find || return 5
    cz -0 -i <(find "${1:-.}" -iwholename "${2:-*}" -type f -print0)
}

cz_find_dir() {
    { hep "$CZ_HELP" && return; } <<EOF
cz find dir [DIRECTORY] [PATTERN]
Select a file under DIRECTORY (or current working directory)
 with full path matching PATTERN.
EOF
    req find || return 5
    cz -0 -i <(find "${1:-.}" -iwholename "${2:-*}" -type d -print0)
}

cz_flatpak_app() {
    { hep "$CZ_HELP" && return; } <<EOF
cz flatpak app
Select an application installed via flatpak.
EOF
    req flatpak || return 5
    cz -f 0  -e 'flatpak info {0}' -i <(flatpak list --app)
}

cz_flatpak_package() {
    { hep "$CZ_HELP" && return; } <<EOF
cz flatpak package [REMOTE]
Select a package available at the given REMOTE then install it.
EOF
    req flatpak || return 5
    local r="";
    if ! r="${1:-$(cz flatpak remote)}"; then
        return 4
    fi
    cz -f 0 -e "flatpak install $r {0}" -i <(flatpak remote-ls "$r")
}

cz_flatpak_remote() {
    { hep "$CZ_HELP" && return; } <<EOF
cz flatpak remote
Select a flatpak remote repository by name.
EOF
    req flatpak || return 5
    cz -i <(flatpak remote-list)
}

cz_flatpak_runtime() {
    { hep "$CZ_HELP" && return; } <<EOF
cz flatpak runtime
Select a runtime installed via flatpak.
EOF
    req flatpak || return 5
    cz -f 0 -e 'flatpak info {0}' -i <(flatpak list --runtime)
}

cz_gcloud_auth() {
       { hep "$CZ_HELP" && return; } <<EOF
cz gcloud auth
Select an available google cloud identity.
EOF
    req gcloud jq || return 5
    cz -f 0 -i <(gcloud auth list --format=json | jq -r '.[] | [.account, .status] | @tsv')
}

cz_gcloud_bucket() {
       { hep "$CZ_HELP" && return; } <<EOF
cz gcloud bucket
Select a google cloud storage bucket.
EOF
    req gsutil || return 5
    cz -i <(gsutil ls)
}

cz_gcloud_bucket_file() {
       { hep "$CZ_HELP" && return; } <<EOF
cz gcloud bucket file [BUCKET]
Select a file from a google cloud storage bucket.
EOF
    req gsutil || return 5
    local b="${1:-$(CZ_FIELDS="" CZ_MODE="" cz -q gcloud bucket)}"
    if [ -z "$b" ]; then return 2; fi
    cz -f 2 -i <(gsutil ls -lr "$b"'**' | sed '$d')
}

cz_gcloud_bq_dataset() {
       { hep "$CZ_HELP" && return; } <<EOF
cz gcloud bq dataset [PROJECT]
Select a Google Bigquery dataset from PROJECT and describe it in JSON.
EOF
    req bq jq || return 5
    local proj="${1:-$(CZ_FIELDS="" CZ_MODE="" cz -q gcloud project)}"
    cz -f 0 -i <(bq --format json --project_id "$proj" ls | \
                     jq -r '.[] | [.id, (.datasetReference | (.datasetId, .projectId)), .location] | @tsv')
}

cz_gcloud_bq_table() {
       { hep "$CZ_HELP" && return; } <<EOF
cz gcloud bq table [PROJECT] [DATASET]
Select a Google Bigquery table from DATASET in PROJECT and describe it in JSON.
EOF
    req bq jq || return 5
    local proj="${1:-$(cz -q gcloud project)}"
    if [ -z "$proj" ]; then
        return 2
    fi
    local ds="${2:-$(cz -q gcloud bq dataset "$proj")}"
    if [ -z "$ds" ]; then
        return 2
    fi
    cz -f 0 -i <(bq --format json --project_id "$proj" ls "$ds" | \
                     jq -r '.[] | [.id, (.tableReference | (.tableId, .datasetId, .projectId)), .type] | @tsv')
}

cz_gcloud_compute_image() {
       { hep "$CZ_HELP" && return; } <<EOF
cz gcloud compute image [PROJECT]
Select a Google cloud compute image in PROJECT and describe it in JSON.
EOF
    req gcloud jq || return 5
    local proj="${1:-$(cz -q gcloud project)}"
    if [ -z "$proj" ]; then return 2; fi
    cz -f 1 -e "gcloud --project $proj --format json compute --format json describe {0} " \
       -i <(gcloud --project "$proj" --format json compute images list | jq -r '.[] | [.name, .creationTimestamp ] | @tsv')
}

cz_gcloud_compute_instance() {
       { hep "$CZ_HELP" && return; } <<EOF
cz gcloud compute instance [PROJECT]
Select a Google cloud compute instance in PROJECT and describe it in JSON.
EOF
    req gcloud jq || return 5
    local proj="${1:-$(cz -q gcloud project)}"
    if [ -z "$proj" ]; then return 2; fi
    cz -f 1 -e "gcloud --project $proj --format json compute instances describe --zone {2} {1}" \
       -i <(gcloud --project "$proj" --format json compute instances list \
                | jq -r '.[] | [.id, .name, (.zone | split("/")[-1]), .networkInterfaces[0].networkIP // "-", .accessConfigs[0].natIP // "-", .status] | @tsv')
}

cz_gcloud_dns_record() {
       { hep "$CZ_HELP" && return; } <<EOF
cz gcloud compute image [PROJECT] [ZONE]
Select a Google cloud DNS record in PROJECT and describe it in JSON.
EOF
    req gcloud jq || return 5
    local proj="${1:-$(CZ_MODE="" CZ_FIELDS="" cz -q gcloud project)}"
    local zone="${2:-$(CZ_MODE="" CZ_FIELDS="" cz -q gcloud dns zone)}"
    if [ -z "$proj" ] || [ -z "$zone" ]; then return 2; fi
    cz -f 0,1 \
       -i <(gcloud --project "$proj" --format json dns record-sets list -z "$zone" | \
                jq -r '.[] | [.type, .name, .ttl, .rrdatas[]] | @tsv')
}

cz_gcloud_dns_zone() {
    { hep "$CZ_HELP" && return; } <<EOF
cz gcloud dns zone [PROJECT]
Select a Google cloud DNS zone in PROJECT and describe it in JSON.
EOF
    req gcloud jq || return 5
    local proj="${1:-$(CZ_MODE="" CZ_FIELDS="" cz -q gcloud project)}"
    if [ -z "$proj" ]; then return 2; fi
    cz -f 0 -e "gcloud --project $proj --format json dns managed-zones describe {0}" \
       -i <(gcloud --project "$proj" --format json dns managed-zones list | \
                jq -r '.[] | [.name, .dnsName, .visibility, .description] | @tsv')
}

cz_gcloud_project() {
    { hep "$CZ_HELP" && return; } <<EOF
cz gcloud project
Select a Google cloud project and describe it in JSON.
EOF
    req gcloud jq || return 5
    cz -f 0 -e 'gcloud --format json projects describe {0}' \
       -i <(gcloud --format json projects list | jq -r '.[] | [.projectId, .name] | @tsv')
}

cz_gcloud_role() {
    { hep "$CZ_HELP" && return; } <<EOF
cz gcloud role [PROJECT]
Select a Google cloud IAM role from PROJECT and describe it in JSON.
EOF
    req gcloud jq || return 5
    local proj="${1:-$(cz -q gcloud project)}"
    if [ -z "$proj" ]; then return 2; fi
    cz -f 0 -e "gcloud --project $proj --format json iam roles describe {0}" \
       -i <(gcloud --project "$proj" --format json iam roles list | jq -r '.[] | [.name, .description] | @tsv')
}

cz_gcloud_serviceaccount() {
       { hep "$CZ_HELP" && return; } <<EOF
cz gcloud serviceaccount [PROJECT]
Select a Google cloud service account from PROJECT and describe it in JSON.
EOF
    req gcloud jq || return 5
    local proj="${1:-$(cz -q gcloud project)}"
    if [ -z "$proj" ]; then return 2; fi
    cz -f 0 -e "gcloud --project $proj --format json iam service-accounts describe {0}" \
       -i <(gcloud --project "$proj" --format json iam service-accounts list | jq -r '.[] | [.email, .displayName, .email] | @tsv')
}

cz_git() {
    cz git status "$@"
}

cz_git_status() {
    { hep "$CZ_HELP" && return; } <<EOF
cz git status [DIRECTORY]
Select a modified file in the git repository in DIRECTORY.
EOF
    req git grep || return 5
    local repo="${1:-.}"
    cz -f 1 -e 'git diff {1}' -i <(git -C "$repo" status -sbu | grep -v ^#)
}

cz_git_branch() {
    { hep "$CZ_HELP" && return; } <<EOF
cz git branch [DIRECTORY]
Select a branch from the git repository in DIRECTORY.
EOF
    req git sed || return 5
    local repo="${1:-.}"
    cz -f 0 -i <(git -C "$repo" branch -vv | sed 's/^[* ] //')
}

cz_git_commit() {
    { hep "$CZ_HELP" && return; } <<EOF
cz git commit [DIRECTORY] [FILE]
Select a commit from the history of the git repository in DIRECTORY.
Given FILE, select a commit that modified that file.
EOF
    req git || return 5
    local repo="${1:-.}"
    local file="${2}"
    cz -f 0 -e "git -C $repo show {0}" \
           -i <(git -C "$repo" log --pretty=format:'%h %cI %s (%ce)' --abbrev-commit -- "$file")
}

cz_git_file()  {
    { hep "$CZ_HELP" && return; } <<EOF
cz git file [DIRECTORY]
Select a branch from the git repository in DIRECTORY.
EOF
    req git grep || return 5
    local repo="${1:-.}"
    cz -f 4: -i <(git -C "$repo" ls-tree -rl HEAD)
}

cz_git_remote() {
    { hep "$CZ_HELP" && return; } <<EOF
cz git remote [DIRECTORY]
Select a remote defined in the git repository in DIRECTORY.
EOF
    req git || return 5
    local repo="${1:-.}"
    cz -f 1 -i <(git -C "$repo" remote -v)
}

cz_git_tag() {
    { hep "$CZ_HELP" && return; } <<EOF
cz git tag [DIRECTORY]
Select a tag from the git repository in DIRECTORY.
EOF
    req git || return 5
    local repo="${1:-.}"
    cz -f 0 -i <(git -C "$repo" tag)
}

cz_help() {
    { hep "$CZ_HELP" && return; } <<EOF
cz help [DIRECTORY]
Select a cz plugin and print its usage text.
EOF
    cz -e 'cz -h {0}' -i <(cz -l)
}

cz_hg_branch() {
    { hep "$CZ_HELP" && return; } <<EOF
cz hg branch [DIRECTORY]
Select a branch in the hg repository in DIRECTORY.
EOF
    req hg || return 5
    cz -f 0 -i <(hg -R "${1:-.}" branches)
}

cz_hg_revision() {
    { hep "$CZ_HELP" && return; } <<EOF
cz hg revision [DIRECTORY]
Select a revision in the hg repository in DIRECTORY.
EOF
    req hg || return 5
    cz -f 0 -i <(hg log -T '{rev} {branch} {user} {date} {desc|firstline}\n' "${1:-.}")
}

cz_hg_status() {
    { hep "$CZ_HELP" && return; } <<EOF
cz hg status [DIRECTORY]
Select a modified file in the hg repository in DIRECTORY.
EOF
    req hg || return 5
    cz -f 1 -i <(hg -R "${1:-.}" status)
}

cz_info()  {
    { hep "$CZ_HELP" && return; } <<EOF
cz info [QUERY]
Select an info page matching QUERY and open it for reading.
EOF
    CZ_DMENU_COLOR="${CZ_DMENU_COLOR:-white:blue:black:green}"
    req info || return 5
    cz -e 'info {0}' -i <(info -k "${1:-.}")
}

cz_ip_addr4() {
    { hep "$CZ_HELP" && return; } <<EOF
cz ip addr4
Select an IPv4 interface configured on the system.
EOF
    req ip || return 5
    cz -f 2 -i <(ip -br -4 addr)
}

cz_ip_addr6() {
    { hep "$CZ_HELP" && return; } <<EOF
cz ip addr6
Select an IPv6 interface configured on the system.
EOF
    req ip || return 5
    cz -f 2 -i <(ip -br -6 addr)
}

cz_ip_route4() {
    { hep "$CZ_HELP" && return; } <<EOF
cz ip addr4
Select an IPv4 route configured on the system.
EOF
    req ip || return 5
    cz -f 0 -i <(ip -4 route)
}

cz_ip_route6() {
    { hep "$CZ_HELP" && return; } <<EOF
cz ip addr6
Select an IPv6 route configured on the system.
EOF
    req ip || return 5
    cz -f 0 -i <(ip -6 route)
}

cz_ispell() {
    { hep "$CZ_HELP" && return; } <<EOF
cz ispell < MISPELLED > FIXED
Select options for mispelled words in the input text.
Print text with updated to replace words with selections.
EOF
    req ispell || return 5
    # parse ispell spellcheck output
    mapfile -t lines
    local line="" index=0 fix=""
    while read -r symbol rest; do
        line="${lines[$index]}"
        case "$symbol" in
            '') # next
                let index++
                continue
                ;;
            '?') # guess
                : ;;
            '&') # miss
                read -r bad _ _ sug   <<< "$rest"
                IFS=', ' read -r -a fixes <<< "$sug"
                fix=$(printf "%s\n" "$bad" "${fixes[@]}" | cz)
                if [ -n "$fix" ]; then
                    lines["$index"]="${line/$bad/$fix}"
                fi
                ;;
            '#') # no guess
                continue
                ;;
            '*') # okay
                continue
                ;;
            '+') # root
                continue
                ;;
        esac
    done < <(printf "%s\n" "${lines[@]}" | ispell -a)
    printf "%s\n" "${lines[@]}"
}

cz_jq() {
    cz jq json "$@"
}

cz_jq_json() {
    { hep "$CZ_HELP" && return; } <<EOF
cz jq json [JSON-FILE] [< JSON-STREAM]
Select from jq path strings for each element of the input file or stream
 then use that path to extract the JSON element.
EOF
    req jq || return 5
    local f=""
    if ! f=$(acc "${1:-/dev/stdin}"); then
        return 4
    fi
    cz -e "jq -r {0} $f" < <(jq -r '"." + (path(..) | map("[\(tojson)]") | join(""))' "$f")
}

cz_jq_yaml() {
    { hep "$CZ_HELP" && return; } <<EOF
cz jq yaml [YAML-FILE] [< YAML-STREAM]
Select from jq path strings for each element of the input file or stream
 then use that path to extract the YAML element.
EOF
    req jq perl || return 5
    local f=""
    if ! f=$(acc "${1:-/dev/stdin}"); then
        return 4
    fi
    local y
    if ! y=$(perl -MYAML -MJSON -E 'say encode_json(Load(do{local $/;<>}))' < "$f"); then
        return 5
    fi
    cz jq json <<< "$y"
}

cz_kill() {
    { hep "$CZ_HELP" && return; } <<EOF
cz kill [PID]
Select a running process then select a signal and send it to the selected process.
EOF
    CZ_DMENU_COLOR="${CZ_DMENU_COLOR:-black:red:green:black}"
    local pid
    if ! pid="${1:-$(cz process)}"; then return 2; fi
    cz -e "kill -s {0} $pid" signal
}

cz_lastpass() {
    { hep "$CZ_HELP" && return; } <<EOF
cz lastpass
Select the ID of a LastPass entry then look up the password component.
EOF
    CZ_DMENU_COLOR="${CZ_DMENU_COLOR:-white:dark blue:black:red}"
    req lpass || return 5
    local menu=()
    local pat='^(.*[^/]) \[id: ([[:digit:]]+)\]$'
    while read -r item; do
        if [[ "$item" =~ $pat ]]; then
            menu+=("${BASH_REMATCH[2]} ${BASH_REMATCH[1]}")
        fi
    done < <(lpass ls)
    cz -e "lpass show --password {0}" < <(printf "%s\n" "${menu[@]}")
}

cz_lineno() {
    { hep "$CZ_HELP" && return; } <<EOF
cz lineno [FILE] [< STREAM]
Select a line number from the input file or stream.
EOF
    req grep || return 5
    local f=""
    if ! f=$(acc "${1:-/dev/stdin}"); then
        return 4
    fi
    cz -d : -f 0 < <(grep -n . "$f")
}

cz_locate() {
    { hep "$CZ_HELP" && return; } <<EOF
cz locate [GLOB ...]
Select a file from the locate database matching the given glob strings.
EOF
    req locate || return 5
    cz -0 -i <(locate -i -0 "${@:-$PWD}")
}

cz_locate_mimetype() {
    { hep "$CZ_HELP" && return; } <<EOF
cz locate [QUERY ...]
Select a mimetype then select a file from the locate database matching its known extensions.
EOF
    req locate || return 5
    local e=($(cz -q -f 1: mimetype))
    if ! ((${#e})); then return 2; fi
    cz locate "${e[@]/#/*.}"
}

cz_locate_regex() {
    { hep "$CZ_HELP" && return; } <<EOF
cz locate regex [PATTERN ...]
Select a file from the locate database matching the given regular expressions.
EOF
    req locate || return 5
    cz -0 -i <(locate -i -0 -r "${@:-.}")
}

cz_man() {
    { hep "$CZ_HELP" && return; } <<EOF
cz man [QUERY]
Select a manual page matching QUERY and open it for reading.
EOF
    CZ_DMENU_COLOR="${CZ_DMENU_COLOR:-black:white:yellow:black}"
    req man sed || return 5
    cz -f 0 -e 'man {0}' -i <(man -k "${1:-.}" | sed 's/ (/./;s/)//')
}

cz_meta() {
    { hep "$CZ_HELP" && return; } <<EOF
cz meta [MODE-OPTION] [PREFIX]
Select a cz plugin starting with prefix and run it in the given mode.
Mode options are -p -q -r -s. The default mode is -p.
This plugin is best used bound to a key, providing a quick
 interface to every other cz plugin.
Examples:
 $ bind -x '"\C-xx":rleval "cz meta -q"' # insert field
 $ bind -x '"\C-xX":rleval "cz meta -p"' # insert line
 $ bind -x '"\C-xz":rleval "cz meta -r"' # insert command output
 $ bind -x '"\C-xZ":rleval "cz meta -s"' # insert command
EOF
    local mode="-p"
    local opt OPTIND OPTARG
    while getopts ":pqrs" opt; do
        case "$opt" in
            [pqrs])
                mode="-$opt"
                ;;
            \?)
                printf "Bad option: -%s\n" "$OPTARG" >&2
                return 2
                ;;
        esac
    done
    shift $((OPTIND - 1))
    cz -f 0 -e "cz ${mode} {0}" -i <(compgen -W "$(cz -l)" -- "$1")
}

cz_mimetype() {
    { hep "$CZ_HELP" && return; } <<EOF
cz mimetype
Select a mimetype and related file extensions.
EOF
    req grep /etc/mime.types || return 5
    cz -f 0 -i <(grep -v -e '^#' -e '^$' /etc/mime.types)
}

declare t="" f=""
for t in artist album genre composer; do
    eval "
cz_mpd_$t() {
    { hep \"\$CZ_HELP\" && return; } <<EOF
cz mpd $t
Select from available mpd database $t tags.
EOF
    req mpc || return 5
    cz -e 'mpc search $t \"{0:}\"' -i <(mpc list $t)
}"
done
unset t f

cz_mpd_output() {
    { hep "$CZ_HELP" && return; } <<EOF
cz mpd output
Select an mpd output and toggle it between enabled and disabled.
EOF
    req mpc || return 5
    cz -e "mpc toggleoutput {1}" -i <(mpc outputs)
}

cz_mpd_search() {
    { hep "$CZ_HELP" && return; } <<EOF
cz mpd search [KIND]
Select an mpd tag of the given kind then select for songs matching that tag.
EOF
    req mpc || return 5
    local kind="${1:-$(CZ_MODE="" cz -p argv artist album genre composer)}"
    if [ -z "$kind" ]; then return 2; fi
    cz -i <(CZ_MODE="" CZ_TEMPLATE="" cz -r mpd "$kind")
}

cz_mpd_seek() {
    { hep "$CZ_HELP" && return; } <<EOF
cz mpd seek
Select a percentage of the current song then seek to that position.
EOF
    req mpc || return 5
    cz -f 0 -e "mpc seek {0}" \
       -i <(printf "%s%%\n" {100..0..5})
}

cz_mpd_track() {
    { hep "$CZ_HELP" && return; } <<EOF
cz mpd track
Select a track number from the current mpd playlist then play that track.
EOF
    CZ_DMENU_COLOR="${CZ_DMENU_COLOR:-white:blue:blue:white}"
    req mpc || return 5
    cz -f 0 -e "mpc play {0}" \
           -i <(mpc -f '%position% [%artist% - %album% - %title%] --  %file%' playlist)
}

cz_nss_group() {
    { hep "$CZ_HELP" && return; } <<EOF
cz nss group
Select a system group.
EOF
    req getent || return 5
    cz -f 0 -d : -i <(getent group)
}

cz_nss_host() {
    { hep "$CZ_HELP" && return; } <<EOF
cz nss host
Select a host from the system host name database.
EOF
    req getent || return 5
    cz -f 0 -i <(getent hosts)
}

cz_nss_network() {
    { hep "$CZ_HELP" && return; } <<EOF
cz nss network
Select a network from the system network database.
EOF
    req getent || return 5
    cz -f 0 -i <(getent networks)
}

cz_nss_passwd() {
    { hep "$CZ_HELP" && return; } <<EOF
cz nss passwd
Select a system user.
EOF
    req getent || return 5
    cz -f 0 -d : -i <(getent passwd)
}

cz_nss_protocol() {
    { hep "$CZ_HELP" && return; } <<EOF
cz nss protocol
Select a protocol from the system protocol database.
EOF
    req getent || return 5
    cz -f 1 -i <(getent protocols)
}

cz_nss_service() {
    { hep "$CZ_HELP" && return; } <<EOF
cz nss service
Select a service from the system service database.
EOF
    req getent || return 5
    cz -f 1 -i <(getent services)
}

cz_pass() {
    { hep "$CZ_HELP" && return; } <<EOF
cz pass
Select an entry from a pass directory and print its contents.
EOF
    CZ_DMENU_COLOR="${CZ_DMENU_COLOR:-white:dark blue:black:green}"
    req pass find sed head || return 5
    local pdir="${PASSWORD_STORE_DIR:-$HOME/.password-store}"
    cz -f 0 -e 'pass show {0} | head -n1' \
           -i <(find "$pdir" -type f -name '*.gpg' | sed "s#\.gpg##; s#$pdir##")
}

cz_pci() {
    { hep "$CZ_HELP" && return; } <<EOF
cz pci
Select a PCI device.
EOF
    req lspci || return 5
    cz -f 0 -i <(lspci)
}

cz_perl_module() {
    { hep "$CZ_HELP" && return; } <<EOF
cz perl module
Select an installed perl module.
EOF
    req perldoc perldoc-search || return 5
    cz -f 0 -i <(perl -MExtUtils::Installed  -E 'say for ExtUtils::Installed->new->modules')
}

cz_perl_doc() {
    { hep "$CZ_HELP" && return; } <<EOF
cz perl doc
Select a perldoc page and open it for reading.
EOF
    req perldoc perldoc-search || return 5
    cz -f 0 -e "perldoc {0}" < <(perldoc-search .)
}

cz_process() {
    { hep "$CZ_HELP" && return; } <<EOF
cz process
Select a system process by PID.
EOF
    CZ_DMENU_COLOR="${CZ_DMENU_COLOR:-white:blue:black:orange}"
    req ps || return 5
    local cols index table
    mapfile table < <(ps ux)
    read -r -a cols <<< "${table[0]}"
    for ((index=1; index <= "${#cols[@]}"; index++)) ; do
        if [[ "${cols[$index]}" =~ ^(pid|PID)$ ]]; then break; fi
    done
    cz -f "$index" <<< "${table[@]:1}"
}

cz_pydoc() {
    { hep "$CZ_HELP" && return; } <<EOF
cz pydoc
Select a python document and open it for reading.
EOF
    req pydoc || return 5
    cz -f 0 -e "pydoc {0}" < <(pydoc -k .)
}

cz_pulseaudio_sink() {
    { hep "$CZ_HELP" && return; } <<EOF
cz pulseaudio sink
Select a pulseaudio sink and toggle its mute state.
EOF
    req pactl || return 5
    cz -f 0 -e 'pactl set-sink-mute {0} toggle' -i <(pactl list short sinks)
}

cz_pulseaudio_sink_volume() {
    { hep "$CZ_HELP" && return; } <<EOF
cz pulseaudio sink
Select a pulseaudio sink and a percentage to set its volume.
EOF
    req pactl || return 5
    local sink
    if ! sink=$(cz -q pulseaudio sink); then return 2; fi
    cz -f 0 -e "pactl set-sink-volume $sink {0}" -i <(printf "%s%%\n" {100..0..5})
}

cz_pulseaudio_source() {
    { hep "$CZ_HELP" && return; } <<EOF
cz pulseaudio source
Select a pulseaudio source and toggle its mute state.
EOF
    req pactl || return 5
    cz -f 0 -e 'pactl set-source-mute {0} toggle' -i <(pactl list short sources)
}

cz_screen_session() {
    { hep "$CZ_HELP" && return; } <<EOF
cz screen session
Select a screen session and attach to it.
EOF
    req screen || return 5
    cz -f 0 -e 'screen -rd {0}' -i <(screen -ls | grep pts)
}

cz_signal() {
    { hep "$CZ_HELP" && return; } <<EOF
cz signal
Select a system signal.
EOF
    CZ_DMENU_COLOR="${CZ_DMENU_COLOR:-white:blue:black:red}"
    local name line signals
    declare -a signals
    for x in {1..64}; do
        name=$(kill -l "$x")
        if [ -z "$name" ]; then continue; fi
        line=$(printf "%02d %s\n" "$x" "$name")
        signals+=("$line")
    done
    cz -f 0 < <(printf "%s\n" "${signals[@]}")
}

cz_ssh() {
    cz ssh host "$@"
}

cz_ssh_host() {
    { hep "$CZ_HELP" && return; } <<EOF
cz ssh host
Select a host from SSH configuration then connect to that host.
EOF
    req ssh sed || return 5
    cz -f 0 -e 'ssh -t {0}' -i <(sed -E -n 's/^\s*Host\s+(.*)\s*/\1/ip' < "$HOME/.ssh/config")
}

cz_ssh_key() {
    { hep "$CZ_HELP" && return; } <<EOF
cz ssh key
Select a key available to the running ssh-agent.
EOF
    req ssh-add || return 5
    cz -f 2 -i < <(ssh-add -l)
}

cz_surfraw() {
    { hep "$CZ_HELP" && return; } <<EOF
cz surfraw [QUERY]
Select a surfraw elvi in a running ssh-agent.
EOF
    req surfraw || return 5
    cz -f 0 -e "surfraw {0} \"$1\"" < <(surfraw -elvi | sed 1d)
}

cz_sysctl() {
    { hep "$CZ_HELP" && return; } <<EOF
cz sysctl
Select a kernel parameter.
EOF
    req sysctl || return 5
    cz -f 0 -i <(sysctl -a 2>/dev/null)
}

cz_systemd_unit() {
    { hep "$CZ_HELP" && return; } <<EOF
cz systemd unit
Select a systemd unit then check its status.
EOF
    req systemctl || return 5
    cz -f 0 -e 'systemctl status {0}' \
       -i <(systemctl list-units -l --plain --no-legend)
}

cz_systemd_service() {
    { hep "$CZ_HELP" && return; } <<EOF
cz systemd service
Select a systemd service and check its status.
EOF
    req systemctl || return 5
    cz -f 0 -e 'systemctl status {0}' \
       -i <(systemctl list-units -l --type=service --plain --no-legend)
}

cz_systemd_socket() {
    { hep "$CZ_HELP" && return; } <<EOF
cz systemd service
Select a systemd socket and check its status.
EOF
    req systemctl || return 5
    cz -f 0 -e 'systemctl status {0}' \
       -i <(systemctl list-units -l --type=socket --plain --no-legend)
}

cz_systemd_timer() {
    { hep "$CZ_HELP" && return; } <<EOF
cz systemd service
Select a systemd timer and check its status.
EOF
    req systemctl || return 5
    cz -f 0 -e 'systemctl status {0}' \
       -i <(systemctl list-units -l --type=timer --plain --no-legend)
}

cz_timezone() {
    { hep "$CZ_HELP" && return; } <<EOF
cz timezone
Select a timezone and print the current time in that region.
EOF
    local p="/usr/share/zoneinfo/posix"
    if req date timedatectl 2>/dev/null; then
        cz -f 0 -e 'TZ={0} date' \
           -i <(timedatectl list-timezones)
    elif req date "$p" sort 2>/dev/null; then
        cz -f 0 -e 'TZ={0} date' \
           -i <(for x in "$p"/*/*; do printf "%s\n" "${x##$p/}"; done | sort)
    else
        req systemd "$p"
    fi
}

cz_tmux_command() {
    { hep "$CZ_HELP" && return; } <<EOF
cz tmux command
Select a tmux command.
EOF
    req tmux || return 5
    cz -f 0 -i <(tmux list-commands)
}

cz_tmux_pane() {
    { hep "$CZ_HELP" && return; } <<EOF
cz tmux pane
Select a pane in the current tmux session and give it focus.
EOF
    req tmux || return 5
    cz -d : -f 0 -e 'tmux select-pane -t {0}' -i <(tmux list-panes)
}

cz_tmux_session() {
    { hep "$CZ_HELP" && return; } <<EOF
cz tmux session
Select a tmux session then attach to it.
EOF
    req tmux || return 5
    cz -d : -f 0 -e 'tmux attach-session -t {0}' -i <(tmux list-sessions)
}

cz_tmux_window() {
    { hep "$CZ_HELP" && return; } <<EOF
cz tmux session
Select a tmux window then switch to it.
EOF
    req tmux || return 5
    cz -d : -f 0 -e 'tmux select-window -t {0}' -i <(tmux list-windows)
}

cz_unicode() {
    cz unicode character "$@"
}

cz_unicode_character() {
    { hep "$CZ_HELP" && return; } <<EOF
cz unicode character [BLOCK]
Select a unicode character from BLOCK.
Interactively select a block if one is not given.
EOF
    req perl || return 5
    local block="${1:-$(CZ_MODE="" CZ_FIELDS="" CZ_TEMPLATE="" cz -p unicode block)}"
    if [ -z "$block" ]; then return 2; fi
    cz -f 0 -d : \
       -i <(perl -MUnicode::UCD=charinfo,charblock,charblocks \
                 -E 'use open ":std", ":encoding(UTF-8)";' \
                 -E 'my $b = shift; exit(1) unless %{charblocks()}{$b};' \
                 -E 'my ($s, $e) = @{charblock($b)->[0]};' \
                 -E 'say join ":", chr hex $_->{code}, $k, $_->{name} for map { charinfo($_) } ($s .. $e)' \
                 "$block")
}

cz_unicode_block() {
    { hep "$CZ_HELP" && return; } <<EOF
cz unicode block
Select a unicode block by name.
EOF
    req perl || return 5
    cz -f 0: -i <(perl -MUnicode::UCD=charblocks -E 'say for sort keys %{charblocks()}')
}

cz_unicode_script() {
    { hep "$CZ_HELP" && return; } <<EOF
cz unicode script
Select a unicode script by name.
EOF
    req perl || return 5
    cz -f 0: -i <(perl -MUnicode::UCD=charscripts -E 'say for sort keys %{charscripts()}')
}

cz_uri() {
    { hep "$CZ_HELP" && return; } <<EOF
cz uri [FILE] [< STREAM]
Select a URI extracted from the input text.
EOF
    CZ_DMENU_COLOR="${CZ_DMENU_COLOR:-white:black:black:green}"
    local f=""
    if ! f=$(acc "${1:-/dev/stdin}"); then
        return 4
    fi
    if type urifind &>/dev/null; then
        cz -e 'sensible-browser {0}' < <(urifind -su < "$f")
    elif type xurls &>/dev/null; then
        cz -e 'sensible-browser {0}' < <(xurls -r < "$f")
    else
        req xurls urifind || return 5
    fi
}

cz_usb() {
    { hep "$CZ_HELP" && return; } <<EOF
cz usb
Select a USB device.
EOF
    req lsusb || return 5
    cz -e 'lsusb -v -d {}' -f 5 -i <(lsusb)
}

cz_word() {
    { hep "$CZ_HELP" && return; } <<EOF
cz word [FILE] [< STREAM]
Select a word from the given file or stream.
EOF
    req grep sort || return 5
    local f=""
    if ! f=$(acc "${1:-/dev/stdin}"); then
        return 4
    fi
    cz < <(grep -Eo '([[:alnum:]])+' "$f" | sort -u)
}

cz_x11_rgb() {
    { hep "$CZ_HELP" && return; } <<EOF
cz x11 rgb
Select a color from a flat database X11 keeps around.
EOF
    req /etc/X11/rgb.txt grep || return 5
    cz -f 0:3 -i <(grep -v '^!' /etc/X11/rgb.txt)
}

cz_x11_window() {
    { hep "$CZ_HELP" && return; } <<EOF
cz x11 window
Select an X11 window.
EOF
    req sort xwininfo || return 5
    local menu=()
    while IFS= read -r l; do
        if [[ "$l" =~ ^[[:space:]]+?(0x[[:alnum:]]+)[[:space:]](.*) ]]; then
            menu+=("${BASH_REMATCH[1]} ${BASH_REMATCH[2]}")
        fi
    done < <(xwininfo -children -root)
    cz -f 0 -i <(printf "%s\n" "${menu[@]}" | sort)
}

xclip_brief() {
    local mod buf lns
    for mod in clipboard primary secondary; do
        buf=$(xclip -o -selection "$mod" 2>/dev/null)
        mapfile lns <<< "$buf"
        printf "%s %s %s\n" "$mod" "${#buf}" "${#lns[@]}"
    done
}

cz_xclip_in() {
    { hep "$CZ_HELP" && return; } <<EOF
cz xclip in
Select a xclip buffer and write the input stream to it.
EOF
    CZ_DMENU_COLOR="${CZ_DMENU_COLOR:-black:dark gray:black:red}"
    req xclip || return 5
    cz -e 'xclip -selection {0} -i' -i <(xclip_brief)
}

cz_xclip_out() {
    { hep "$CZ_HELP" && return; } <<EOF
cz xclip out
Select a xclip buffer and print its contents.
EOF
    CZ_DMENU_COLOR="${CZ_DMENU_COLOR:-black:dark gray:black:green}"
    req xclip || return 5
    cz -e 'xclip -selection {0} -o' -i <(xclip_brief)
}

cz_xml_element() {
    { hep "$CZ_HELP" && return; } <<EOF
cz xml element [FILE] [< STREAM]
Select a XML element by xpath string and print it.
EOF
    req xmlstarlet || return 5
    local f=""
    if ! f=$(acc "${1:-/dev/stdin}"); then
        return 4
    fi
    cz -f 0 -e "xmlstarlet sel -B -t -c {0} $f" < <(xmlstarlet el -v "$f")
}

cz_xml_value() {
    { hep "$CZ_HELP" && return; } <<EOF
cz xml value [FILE] [< STREAM]
Select a XML element by xpath string and extract its contents.
EOF
    req xmlstarlet || return 5
    local f=""
    if ! f=$(acc "${1:-/dev/stdin}"); then
        return 4
    fi
    cz -f 0 -e "xmlstarlet sel -B -t -v {0} $f" < <(xmlstarlet el -v "$f")
}

cz_xrandr_monitor() {
    { hep "$CZ_HELP" && return; } <<EOF
cz xrandr monitor
Select a X11 monitor.
EOF
    req xrandr sed || return 5
    cz -f 0 -i <(xrandr --listmonitors | sed '1d')
}

cz_xrandr_provider() {
    { hep "$CZ_HELP" && return; } <<EOF
cz xrandr provider
Select a X11 provider.
EOF
    req xrandr sed || return 5
    cz -f 0 -i <(xrandr --listproviders | sed '1d')
}

###

# run it unless sourced
if [[ "${BASH_SOURCE[0]}" == "$0" ]]; then cz "$@"; fi
